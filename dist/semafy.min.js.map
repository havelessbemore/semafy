{"version":3,"sources":["webpack://Semafy/webpack/universalModuleDefinition","webpack://Semafy/./src/mutex.ts","webpack://Semafy/./src/rawSemaphore.ts","webpack://Semafy/./src/semaphore.ts","webpack://Semafy/./src/semaphoreError.ts","webpack://Semafy/./src/semaphoreLock.ts","webpack://Semafy/./src/structures/heap.ts","webpack://Semafy/./src/structures/queue.ts","webpack://Semafy/webpack/bootstrap","webpack://Semafy/webpack/runtime/compat get default export","webpack://Semafy/webpack/runtime/define property getters","webpack://Semafy/webpack/runtime/hasOwnProperty shorthand","webpack://Semafy/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","self","Mutex","Semaphore","RawSemaphore","value","queue","LinkedQueue","this","count","callback","setImmediate","SemaphoreError","update","Promise","resolve","reject","wait","err","sem","enqueue","ms","handle","waitFor","handler","error","semaphore","undefined","clearTimeout","setTimeout","size","dequeue","input","clear","tryWait","SemaphoreLock","lock","msg","Error","isAcquired","post","BinaryMinHeap","comparator","array","_comparator","length","last","pop","sinkDown","push","bubbleUp","compare","index","parentIndex","Math","floor","parent","n","childIndex","child","Symbol","iterator","next","done","BinaryMaxHeap","a","b","ArrayQueue","shift","tail","head","PriorityQueue","heap","peek","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","toStringTag"],"mappings":"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","file":"semafy.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Semafy\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Semafy\"] = factory();\n\telse\n\t\troot[\"Semafy\"] = factory();\n})(self, function() {\nreturn ","import { Semaphore } from './semaphore';\n\n/**\n * A convenience class for defining a binary {@link Semaphore} (aka `new Semaphore(1);`).\n *\n * Has the same methods as {@link Semaphore}\n */\nexport class Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\n","import { LinkedQueue, Queue } from './structures';\nimport { SemaphoreError } from './semaphoreError';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link RawSemaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param semaphore - The semaphore being acquired\n */\nexport interface RawSemaphoreCallback {\n    (error: SemaphoreError | undefined, semaphore: RawSemaphore): void;\n}\n\n/**\n * Related to an [unnamed POSIX semaphore](https://man7.org/linux/man-pages/man7/sem_overview.7.html)\n */\nexport class RawSemaphore {\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    protected count: number;\n    /**\n     * The underlying queue to keep track of pending calls\n     */\n    protected queue: Queue<RawSemaphoreCallback>;\n\n    /**\n     * @param value - The initial number of calls allowed to acquire the semaphore concurrently\n     * @param queue - The underlying queue to keep track of pending calls\n     */\n    constructor(value: number, queue: Queue<RawSemaphoreCallback> = new LinkedQueue()) {\n        this.count = value;\n        this.queue = queue;\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        for (const callback of this.queue) {\n            setImmediate(callback, new SemaphoreError(), this);\n        }\n    }\n\n    /**\n     * Increment the semaphore's {@link value} by 1\n     */\n    post(): void {\n        ++this.count;\n        this.update();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns `true` and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     *\n     * Otherwise, returns `false`\n     */\n    tryWait(): boolean {\n        if (this.count < 1) {\n            return false;\n        }\n        --this.count;\n        return true;\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.count;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call acquisition is successful or rejected\n     */\n    wait(callback: RawSemaphoreCallback): void;\n    wait(callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n\n        // Add to queue\n        this.queue.enqueue(callback);\n        this.update();\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: RawSemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n        ms = ms == null ? 0 : ms;\n\n        // Setup timeout\n        let handle: NodeJS.Timeout | undefined;\n        const handler: RawSemaphoreCallback = (error, semaphore) => {\n            if (handle !== undefined) {\n                clearTimeout(handle);\n                handle = undefined;\n                callback(error, semaphore);\n            }\n        };\n        handle = setTimeout(() => handler(new SemaphoreError(), this), ms);\n\n        // Add to queue\n        this.queue.enqueue(handler);\n        this.update();\n    }\n\n    /**\n     * If the semaphore's value is above 0 and there\n     * are calls waiting, remove and unblock the head.\n     */\n    protected update(): void {\n        if (this.count > 0 && this.queue.size > 0) {\n            --this.count;\n            const callback = this.queue.dequeue()!;\n            setImmediate(callback, undefined, this);\n        }\n    }\n}\n","import { RawSemaphore } from './rawSemaphore';\nimport { SemaphoreError } from './semaphoreError';\nimport { SemaphoreLock } from './semaphoreLock';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link Semaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param lock - A {@link SemaphoreLock} to the {@link Semaphore} being acquired. If acquired, the lock will be locked. Otherwise, the lock will be unlocked.\n */\nexport interface SemaphoreCallback {\n    (error: SemaphoreError | undefined, lock: SemaphoreLock): void;\n}\n\nexport class Semaphore {\n    /**\n     * The underlying raw semaphore\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     * Creates a semaphore object\n     *\n     * @param value - The max number of calls allowed to acquire the semaphore concurrently\n     */\n    constructor(value: number);\n    /**\n     * Creates a semaphore object\n     *\n     * @param semaphore - The underlying {@link RawSemaphore}\n     */\n    constructor(semaphore: RawSemaphore);\n    constructor(input: number | RawSemaphore) {\n        if (typeof input === 'number') {\n            this.semaphore = new RawSemaphore(input);\n        } else {\n            this.semaphore = input;\n        }\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        this.semaphore.clear();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns {@link SemaphoreLock} and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     * Otherwise, returns `undefined`\n     */\n    tryWait(): SemaphoreLock | undefined {\n        if (this.semaphore.tryWait()) {\n            return new SemaphoreLock(this.semaphore);\n        }\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.semaphore.value;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    wait(callback: SemaphoreCallback): void;\n    wait(callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.wait((error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: SemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.waitFor(ms, (error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n}\n","/**\n * Indicates an error when a semaphore cannot be acquired.\n *\n * This can be encountered when:\n *    - A semaphore is cleared and all pending calls are rejected.\n *    - A semaphore could not be acquired within a given time limit.\n */\nexport class SemaphoreError extends Error {\n    constructor(msg?: string) {\n        super(msg || 'Unable to acquire semaphore');\n    }\n}\n","import { RawSemaphore } from './rawSemaphore';\n\n/**\n * Represents a lock (acquisition) on a semaphore.\n *\n * Usage imposes the following restrictions:\n * 1. A semaphore must first be acquired (locked) before it can be released (unlocked)\n * 1. If locked, the lock can be unlocked once at most\n * 1. Once unlocked, the lock is exhausted. If needed, a new lock must be acquired via the semaphore\n */\nexport class SemaphoreLock {\n    /**\n     * Whether or not the semaphore is acquired\n     */\n    protected isAcquired: boolean;\n    /**\n     * The semaphore being locked\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     *\n     * @param semaphore - The semaphore being locked\n     * @param isAcquired - Whether or not the semaphore is acquired\n     */\n    constructor(semaphore: RawSemaphore, isAcquired = true) {\n        this.semaphore = semaphore;\n        this.isAcquired = isAcquired;\n    }\n\n    /**\n     * Check if locked\n     */\n    isLocked(): boolean {\n        return this.isAcquired;\n    }\n\n    /**\n     * If locked, then unlock\n     */\n    unlock(): void {\n        if (this.isAcquired) {\n            this.isAcquired = false;\n            this.semaphore.post();\n        }\n    }\n}\n","import { Comparator, Sorted } from './compare';\n\n/**\n * @ignore\n */\nexport interface Heap<T> extends Iterable<T>, Sorted<T> {\n    clear(): void;\n    comparator(): Comparator<T>;\n    peek(): T | undefined;\n    pop(): T | undefined;\n    push(value: T): void;\n    pushPop(value: T): T;\n    replace(value: T): T;\n    readonly size: number;\n}\n\n/**\n * @ignore\n */\nexport class BinaryMinHeap<T> implements Heap<T> {\n    protected _comparator: Comparator<T>;\n\n    constructor(comparator: Comparator<T>, protected array: Array<T> = []) {\n        this._comparator = comparator;\n    }\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    comparator(): Comparator<T> {\n        return this._comparator;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        if (this.array.length < 1) {\n            return undefined;\n        }\n\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Add the last value to\n            // the root and update the heap\n            this.array[0] = last!;\n            this.sinkDown(0);\n        }\n\n        return value;\n    }\n\n    push(value: T): void {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        this.bubbleUp(this.array.length - 1);\n    }\n\n    // Push a new value to the heap and then pop the root\n    pushPop(value: T): T {\n        // If not empty and root < value\n        if (this.array.length > 0 && this._comparator.compare(this.array[0], value) < 0) {\n            // Swap the root and value\n            const root = this.array[0];\n            this.array[0] = value;\n            value = root;\n\n            // Update the heap\n            this.sinkDown(0);\n        }\n        return value;\n    }\n\n    // Pop the root of the heap and then push a new value\n    replace(value: T): T {\n        // If not empty\n        if (this.array.length > 0) {\n            // Swap the root with value\n            const root = this.array[0];\n            this.array[0] = value;\n            value = root;\n\n            // Update the heap\n            this.sinkDown(0);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    protected bubbleUp(index: number): void {\n        const value = this.array[index];\n\n        // Until we reach the top of the heap\n        while (index > 0) {\n            // Get the parent\n            const parentIndex = Math.floor((index + 1) / 2) - 1;\n            const parent = this.array[parentIndex]!;\n\n            // If the parent <= value, the heap is in order\n            if (this._comparator.compare(parent, value) <= 0) {\n                break;\n            }\n\n            // Swap the parent with value and continue\n            this.array[parentIndex] = value;\n            this.array[index] = parent;\n            index = parentIndex;\n        }\n    }\n\n    protected sinkDown(index: number): void {\n        const n = this.array.length;\n        const value = this.array[index];\n\n        do {\n            // Compute the left child's index\n            let childIndex = 2 * index + 1;\n\n            // If no children exist\n            if (childIndex >= n) {\n                break;\n            }\n\n            // Decide which child to compare with\n            let child = this.array[childIndex];\n            if (childIndex + 1 < n && this._comparator.compare(this.array[childIndex + 1]!, child) <= 0) {\n                child = this.array[++childIndex]!;\n            }\n\n            // If value <= child\n            if (this._comparator.compare(value, child) <= 0) {\n                break;\n            }\n\n            // Swap value and child\n            this.array[index] = child;\n            this.array[childIndex] = value;\n            index = childIndex;\n        } while (true);\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.pop()! };\n            },\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class BinaryMaxHeap<T> extends BinaryMinHeap<T> {\n    constructor(comparator: Comparator<T>, array: Array<T>) {\n        comparator = {compare: (a, b) => comparator.compare(b, a)};\n        super(comparator, array);\n    }\n}\n","import { Heap } from './heap';\nimport { Comparator, Sorted } from './compare';\n\n/**\n * @ignore\n */\nexport interface LinkedNode<T> {\n    next?: LinkedNode<T>;\n    value: T;\n}\n\nexport interface Queue<T> extends Iterable<T> {\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void;\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    dequeue(): T | null;\n    /**\n     * Inserts the specified value into this queue\n     *\n     * @param value - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    enqueue(value: T): boolean;\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    peek(): T | null;\n    /**\n     * The number of elements in this queue\n     */\n    readonly size: number;\n}\n\nexport interface SortedQueue<T> extends Queue<T>, Sorted<T> {}\n\n/**\n * @ignore\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    constructor(protected array: Array<T> = []) {}\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    enqueue(value: T): boolean {\n        this.array.push(value);\n        return true;\n    }\n\n    dequeue(): T | null {\n        return this.size < 1 ? null : this.array.shift()!;\n    }\n\n    peek(): T | null {\n        return this.size < 1 ? null : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    protected length: number;\n    protected tail?: LinkedNode<T>;\n\n    constructor() {\n        this.length = 0;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.tail = undefined;\n    }\n\n    dequeue(): T | null {\n        if (this.tail == null) {\n            return null;\n        }\n\n        const head = this.tail.next!;\n        this.tail.next = head.next;\n        if (--this.length < 1) {\n            this.tail = undefined;\n        }\n\n        return head.value;\n    }\n\n    enqueue(value: T): boolean {\n        const tail: LinkedNode<T> = { value };\n\n        if (this.tail == null) {\n            tail.next = tail;\n        } else {\n            tail.next = this.tail.next;\n            this.tail.next = tail;\n        }\n\n        this.tail = tail;\n        ++this.length;\n        return true;\n    }\n\n    peek(): T | null {\n        return this.tail == null ? null : this.tail.next!.value;\n    }\n\n    get size(): number {\n        return this.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class PriorityQueue<T> implements SortedQueue<T> {\n    constructor(protected heap: Heap<T>) {}\n\n    clear(): void {\n        this.heap.clear();\n    }\n\n    comparator(): Comparator<T> {\n        return this.heap.comparator();\n    }\n\n    enqueue(value: T): boolean {\n        this.heap.push(value);\n        return true;\n    }\n\n    dequeue(): T | null {\n        return this.heap.pop() || null;\n    }\n\n    peek(): T | null {\n        return this.heap.peek() || null;\n    }\n\n    get size(): number {\n        return this.heap.size;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}