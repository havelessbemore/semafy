{"version":3,"sources":["webpack://Semafy/webpack/universalModuleDefinition","webpack://Semafy/webpack/bootstrap","webpack://Semafy/webpack/runtime/define property getters","webpack://Semafy/webpack/runtime/hasOwnProperty shorthand","webpack://Semafy/webpack/runtime/make namespace object","webpack://Semafy/./src/queue.ts","webpack://Semafy/./src/semaphoreError.ts","webpack://Semafy/./src/rawSemaphore.ts","webpack://Semafy/./src/semaphoreLock.ts","webpack://Semafy/./src/semaphore.ts","webpack://Semafy/./src/mutex.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ArrayQueue","array","this","length","push","size","shift","iterator","next","done","dequeue","BinaryMinHeap","comparator","undefined","last","pop","sinkDown","bubbleUp","index","parentIndex","Math","floor","parent","n","childIndex","child","LinkedQueue","head","tail","node","PriorityQueue","heap","clear","peek","SemaphoreError","msg","Error","RawSemaphore","queue","count","callback","setImmediate","update","Promise","resolve","reject","wait","err","sem","enqueue","ms","handle","waitFor","handler","error","semaphore","clearTimeout","setTimeout","SemaphoreLock","isAcquired","post","Semaphore","input","tryWait","lock","Mutex"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,SAAU,GAAIH,GACK,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClF,EAAyBd,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,qfCyDhD,IAAMC,EAAb,WACI,aAA4C,IAAtBC,EAAsB,uDAAJ,GAAI,eAAtBA,QAD1B,+BAGI,WACIC,KAAKD,MAAME,OAAS,IAJ5B,qBAOI,SAAQJ,GAEJ,OADAG,KAAKD,MAAMG,KAAKL,IACT,IATf,qBAYI,WACI,OAAOG,KAAKG,KAAO,EAAI,KAAOH,KAAKD,MAAMK,UAbjD,kBAgBI,WACI,OAAOJ,KAAKG,KAAO,EAAI,KAAOH,KAAKD,MAAM,KAjBjD,gBAoBI,WACI,OAAOC,KAAKD,MAAME,SArB1B,KAwBKN,OAAOU,SAxBZ,MAwBI,WAAiC,WAC7B,MAAO,CACHC,KAAM,WACF,OAAO,EAAKH,KAAO,EAAI,CAAEI,MAAM,EAAMV,MAAO,MAAS,CAAEU,MAAM,EAAOV,MAAO,EAAKW,iBA3BhG,KAoCaC,EAAb,WACI,WAAsBC,EAAqCX,GAAiB,eAAtDW,aAAsD,KAAjBX,QAD/D,+BAGI,WACIC,KAAKD,MAAME,OAAS,IAJ5B,kBAOI,WACI,OAAOD,KAAKD,MAAME,OAAS,EAAID,KAAKD,MAAM,QAAKY,IARvD,iBAWI,WAEI,IAAMd,EAAQG,KAAKD,MAAM,GACnBa,EAAOZ,KAAKD,MAAMc,MAUxB,OAPIb,KAAKD,MAAME,OAAS,IAGpBD,KAAKD,MAAM,GAAKa,EAChBZ,KAAKc,SAAS,IAGXjB,IAxBf,kBA2BI,SAAKA,GAEDG,KAAKD,MAAMG,KAAKL,GAGhBG,KAAKe,SAASf,KAAKD,MAAME,OAAS,KAhC1C,qBAoCI,SAAQJ,GAEJ,GAAIG,KAAKD,MAAME,OAAS,GAAKD,KAAKU,WAAWV,KAAKD,MAAM,GAAIF,GAAS,EAAG,CAEpE,IAAMtB,EAAOyB,KAAKD,MAAM,GACxBC,KAAKD,MAAM,GAAKF,EAChBA,EAAQtB,EAGRyB,KAAKc,SAAS,GAElB,OAAOjB,IA/Cf,qBAmDI,SAAQA,GAEJ,GAAIG,KAAKD,MAAME,OAAS,EAAG,CAEvB,IAAM1B,EAAOyB,KAAKD,MAAM,GACxBC,KAAKD,MAAM,GAAKF,EAChBA,EAAQtB,EAGRyB,KAAKc,SAAS,GAGlB,OAAOjB,IA/Df,gBAkEI,WACI,OAAOG,KAAKD,MAAME,SAnE1B,sBAsEI,SAAmBe,GAIf,IAHA,IAAMnB,EAAQG,KAAKD,MAAMiB,GAGlBA,EAAQ,GAAG,CAEd,IAAMC,EAAcC,KAAKC,OAAOH,EAAQ,GAAK,GAAK,EAC5CI,EAASpB,KAAKD,MAAMkB,GAG1B,GAAIjB,KAAKU,WAAWU,EAAQvB,IAAU,EAClC,MAIJG,KAAKD,MAAMkB,GAAepB,EAC1BG,KAAKD,MAAMiB,GAASI,EACpBJ,EAAQC,KAvFpB,sBA2FI,SAAmBD,GAIf,IAHA,IAAMK,EAAIrB,KAAKD,MAAME,OACfJ,EAAQG,KAAKD,MAAMiB,KAEtB,CAEC,IAAIM,EAAa,EAAIN,EAAQ,EAG7B,GAAIM,GAAcD,EACd,MAIJ,IAAIE,EAAQvB,KAAKD,MAAMuB,GAMvB,GALIA,EAAa,EAAID,GAAKrB,KAAKU,WAAWV,KAAKD,MAAMuB,EAAa,GAAKC,IAAU,IAC7EA,EAAQvB,KAAKD,QAAQuB,IAIrBtB,KAAKU,WAAWb,EAAO0B,IAAU,EACjC,MAIJvB,KAAKD,MAAMiB,GAASO,EACpBvB,KAAKD,MAAMuB,GAAczB,EACzBmB,EAAQM,OAtHpB,KA8HaE,EAAb,WAKI,aAAc,UACVxB,KAAKC,OAAS,EANtB,+BASI,WACID,KAAKC,OAAS,EACdD,KAAKyB,KAAOzB,KAAK0B,UAAOf,IAXhC,qBAcI,WACI,GAAiB,MAAbX,KAAKyB,KACL,OAAO,KAEX,IAAME,EAAO3B,KAAKyB,KAKlB,OAJAzB,KAAKyB,KAAOE,EAAKrB,OACXN,KAAKC,OAAS,IAChBD,KAAK0B,UAAOf,GAETgB,EAAK9B,QAvBpB,qBA0BI,SAAQA,GACJ,IAAM8B,EAAO,CAAE9B,SAQf,OAPiB,MAAbG,KAAK0B,KACL1B,KAAKyB,KAAOE,EAEZ3B,KAAK0B,KAAKpB,KAAOqB,EAErB3B,KAAK0B,KAAOC,IACV3B,KAAKC,QACA,IAnCf,kBAsCI,WACI,OAAoB,MAAbD,KAAKyB,KAAe,KAAOzB,KAAKyB,KAAK5B,QAvCpD,gBA0CI,WACI,OAAOG,KAAKC,SA3CpB,KA8CKN,OAAOU,SA9CZ,MA8CI,WAAiC,WAC7B,MAAO,CACHC,KAAM,WACF,OAAO,EAAKH,KAAO,EAAI,CAAEI,MAAM,EAAMV,MAAO,MAAS,CAAEU,MAAM,EAAOV,MAAO,EAAKW,iBAjDhG,KA0DaoB,EAAb,WACI,WAAsBC,GAAe,eAAfA,OAD1B,+BAGI,WACI7B,KAAK6B,KAAKC,UAJlB,qBAOI,SAAQjC,GAEJ,OADAG,KAAK6B,KAAK3B,KAAKL,IACR,IATf,qBAYI,WACI,OAAOG,KAAK6B,KAAKhB,OAAS,OAblC,kBAgBI,WACI,OAAOb,KAAK6B,KAAKE,QAAU,OAjBnC,gBAoBI,WACI,OAAO/B,KAAK6B,KAAK1B,OArBzB,KAwBKR,OAAOU,SAxBZ,MAwBI,WAAiC,WAC7B,MAAO,CACHC,KAAM,WACF,OAAO,EAAKH,KAAO,EAAI,CAAEI,MAAM,EAAMV,MAAO,MAAS,CAAEU,MAAM,EAAOV,MAAO,EAAKW,iBA3BhG,K,6iDCnRO,IAAMwB,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,mJACI,WAAYC,GAAc,O,4FAAA,qBAChBA,GAAO,+BAFrB,YAAoCC,Q,8WCS7B,IAAMC,EAAb,WAcI,WAAYtC,GAAuE,IAAxDuC,EAAwD,uDAAnB,IAAIZ,EAAe,UAC/ExB,KAAKqC,MAAQxC,EACbG,KAAKoC,MAAQA,E,QAhBrB,O,EAAA,G,EAAA,oBAsBI,WAAc,Q,25BAAA,CACapC,KAAKoC,OADlB,IACV,2BAAmC,KAAxBE,EAAwB,QAC/BC,aAAaD,EAAU,IAAIN,EAAkBhC,OAFvC,iCAtBlB,kBA+BI,aACMA,KAAKqC,MACPrC,KAAKwC,WAjCb,qBA2CI,WACI,QAAIxC,KAAKqC,MAAQ,MAGfrC,KAAKqC,MACA,MAhDf,iBAsDI,WACI,OAAOrC,KAAKqC,QAvDpB,kBA4EI,SAAKC,GAAsE,WAEvE,GAAgB,MAAZA,EACA,OAAO,IAAIG,SAAQ,SAACC,EAASC,GACzB,EAAKC,MAAK,SAACC,EAAKC,GAAN,OAAeD,EAAMF,EAAOE,GAAOH,EAAQI,SAK7D9C,KAAKoC,MAAMW,QAAQT,GACnBtC,KAAKwC,WAtFb,qBA8GI,SAAQQ,EAAoBV,GAAsE,IAU1FW,EAV0F,OAE9F,GAAgB,MAAZX,EACA,OAAO,IAAIG,SAAQ,SAACC,EAASC,GACzB,EAAKO,QAAQF,GAAI,SAACH,EAAKC,GAAN,OAAeD,EAAMF,EAAOE,GAAOH,EAAQI,SAGpEE,EAAW,MAANA,EAAa,EAAIA,EAItB,IAAMG,EAAgC,SAACC,EAAOC,QAC3B1C,IAAXsC,IACAK,aAAaL,GACbA,OAAStC,EACT2B,EAASc,EAAOC,KAGxBJ,EAASM,YAAW,kBAAMJ,EAAQ,IAAInB,EAAkB,KAAOgB,GAG/DhD,KAAKoC,MAAMW,QAAQI,GACnBnD,KAAKwC,WApIb,oBA2II,WACI,GAAIxC,KAAKqC,MAAQ,GAAKrC,KAAKoC,MAAMjC,KAAO,EAAG,GACrCH,KAAKqC,MACP,IAAMC,EAAWtC,KAAKoC,MAAM5B,UAC5B+B,aAAaD,OAAU3B,EAAWX,Y,iBA/I9C,K,oQCNO,IAAMwD,EAAb,WAeI,WAAYH,GAA4C,IAAnBI,IAAmB,mEACpDzD,KAAKqD,UAAYA,EACjBrD,KAAKyD,WAAaA,E,QAjB1B,O,EAAA,G,EAAA,uBAuBI,WACI,OAAOzD,KAAKyD,aAxBpB,oBA8BI,WACQzD,KAAKyD,aACLzD,KAAKyD,YAAa,EAClBzD,KAAKqD,UAAUK,a,iBAjC3B,K,sKCIO,IAAMC,EAAb,WAkBI,WAAYC,I,4FAA8B,SAElC5D,KAAKqD,UADY,iBAAVO,EACU,IAAIzB,EAAayB,GAEjBA,E,QAtB7B,O,EAAA,G,EAAA,oBA6BI,WACI5D,KAAKqD,UAAUvB,UA9BvB,qBAuCI,WACI,GAAI9B,KAAKqD,UAAUQ,UACf,OAAO,IAAIL,EAAcxD,KAAKqD,aAzC1C,iBAgDI,WACI,OAAOrD,KAAKqD,UAAUxD,QAjD9B,kBAsEI,SAAKyC,GAAoE,WAErE,GAAgB,MAAZA,EACA,OAAO,IAAIG,SAAQ,SAACC,EAASC,GACzB,EAAKC,MAAK,SAACC,EAAKiB,GAAN,OAAgBjB,EAAMF,EAAOE,GAAOH,EAAQoB,SAK9D9D,KAAKqD,UAAUT,MAAK,SAACQ,EAAON,GACxBR,EAASc,EAAO,IAAII,EAAcV,EAAc,MAATM,SAhFnD,qBAyGI,SAAQJ,EAAoBV,GAAoE,WAE5F,GAAgB,MAAZA,EACA,OAAO,IAAIG,SAAQ,SAACC,EAASC,GACzB,EAAKO,QAAQF,GAAI,SAACH,EAAKiB,GAAN,OAAgBjB,EAAMF,EAAOE,GAAOH,EAAQoB,SAKrE9D,KAAKqD,UAAUH,QAAQF,GAAI,SAACI,EAAON,GAC/BR,EAASc,EAAO,IAAII,EAAcV,EAAc,MAATM,Y,iBAnHnD,K,ioBCPO,IAAMW,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,+YACI,aAAc,O,4FAAA,qBACJ,GAFd,UAA2BJ,G","file":"semafy.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Semafy\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Semafy\"] = factory();\n\telse\n\t\troot[\"Semafy\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @ignore\n */\nexport interface Comparator<T> {\n    (a: T, b: T): number;\n}\n\n/**\n * @ignore\n */\nexport interface LinkedNode<T> {\n    next?: LinkedNode<T>;\n    value: T;\n}\n\n/**\n * @ignore\n */\nexport interface Heap<T> {\n    clear(): void;\n    peek(): T | undefined;\n    pop(): T | undefined;\n    push(value: T): void;\n    pushPop(value: T): T;\n    replace(value: T): T;\n    readonly size: number;\n}\n\nexport interface Queue<T> extends Iterable<T> {\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void;\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    dequeue(): T | null;\n    /**\n     * Inserts the specified value into this queue\n     *\n     * @param value - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    enqueue(value: T): boolean;\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    peek(): T | null;\n    /**\n     * The number of elements in this queue\n     */\n    readonly size: number;\n}\n\n/**\n * @ignore\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    constructor(protected array: Array<T> = []) {}\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    enqueue(value: T): boolean {\n        this.array.push(value);\n        return true;\n    }\n\n    dequeue(): T | null {\n        return this.size < 1 ? null : this.array.shift()!;\n    }\n\n    peek(): T | null {\n        return this.size < 1 ? null : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class BinaryMinHeap<T> implements Heap<T> {\n    constructor(protected comparator: Comparator<T>, protected array: Array<T>) {}\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    peek(): T | undefined {\n        return this.array.length > 0 ? this.array[0] : undefined;\n    }\n\n    pop(): T | undefined {\n        // Get the root and the last value\n        const value = this.array[0];\n        const last = this.array.pop();\n\n        // If value != last\n        if (this.array.length > 0) {\n            // Add the last value to\n            // the root and update the heap\n            this.array[0] = last!;\n            this.sinkDown(0);\n        }\n\n        return value;\n    }\n\n    push(value: T): void {\n        // Add new value to the end of the heap\n        this.array.push(value);\n\n        // Update the heap\n        this.bubbleUp(this.array.length - 1);\n    }\n\n    // Push a new value to the heap and then pop the root\n    pushPop(value: T): T {\n        // If not empty and root < value\n        if (this.array.length > 0 && this.comparator(this.array[0], value) < 0) {\n            // Swap the root and value\n            const root = this.array[0];\n            this.array[0] = value;\n            value = root;\n\n            // Update the heap\n            this.sinkDown(0);\n        }\n        return value;\n    }\n\n    // Pop the root of the heap and then push a new value\n    replace(value: T): T {\n        // If not empty\n        if (this.array.length > 0) {\n            // Swap the root with value\n            const root = this.array[0];\n            this.array[0] = value;\n            value = root;\n\n            // Update the heap\n            this.sinkDown(0);\n        }\n\n        return value;\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    protected bubbleUp(index: number): void {\n        const value = this.array[index];\n\n        // Until we reach the top of the heap\n        while (index > 0) {\n            // Get the parent\n            const parentIndex = Math.floor((index + 1) / 2) - 1;\n            const parent = this.array[parentIndex]!;\n\n            // If the parent <= value, the heap is in order\n            if (this.comparator(parent, value) <= 0) {\n                break;\n            }\n\n            // Swap the parent with value and continue\n            this.array[parentIndex] = value;\n            this.array[index] = parent;\n            index = parentIndex;\n        }\n    }\n\n    protected sinkDown(index: number): void {\n        const n = this.array.length;\n        const value = this.array[index];\n\n        do {\n            // Compute the left child's index\n            let childIndex = 2 * index + 1;\n\n            // If no children exist\n            if (childIndex >= n) {\n                break;\n            }\n\n            // Decide which child to compare with\n            let child = this.array[childIndex];\n            if (childIndex + 1 < n && this.comparator(this.array[childIndex + 1]!, child) <= 0) {\n                child = this.array[++childIndex]!;\n            }\n\n            // If value <= child\n            if (this.comparator(value, child) <= 0) {\n                break;\n            }\n\n            // Swap value and child\n            this.array[index] = child;\n            this.array[childIndex] = value;\n            index = childIndex;\n        } while (true);\n    }\n}\n\n/**\n * @ignore\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    protected length: number;\n    protected head?: LinkedNode<T>;\n    protected tail?: LinkedNode<T>;\n\n    constructor() {\n        this.length = 0;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.head = this.tail = undefined;\n    }\n\n    dequeue(): T | null {\n        if (this.head == null) {\n            return null;\n        }\n        const node = this.head;\n        this.head = node.next;\n        if (--this.length < 1) {\n            this.tail = undefined;\n        }\n        return node.value;\n    }\n\n    enqueue(value: T): boolean {\n        const node = { value };\n        if (this.tail == null) {\n            this.head = node;\n        } else {\n            this.tail.next = node;\n        }\n        this.tail = node;\n        ++this.length;\n        return true;\n    }\n\n    peek(): T | null {\n        return this.head == null ? null : this.head.value;\n    }\n\n    get size() {\n        return this.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class PriorityQueue<T> implements Queue<T> {\n    constructor(protected heap: Heap<T>) {}\n\n    clear(): void {\n        this.heap.clear();\n    }\n\n    enqueue(value: T): boolean {\n        this.heap.push(value);\n        return true;\n    }\n\n    dequeue(): T | null {\n        return this.heap.pop() || null;\n    }\n\n    peek(): T | null {\n        return this.heap.peek() || null;\n    }\n\n    get size(): number {\n        return this.heap.size;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => {\n                return this.size < 1 ? { done: true, value: null } : { done: false, value: this.dequeue()! };\n            },\n        };\n    }\n}\n","/**\n * Indicates an error when a semaphore cannot be acquired.\n *\n * This can be encountered when:\n *    - A semaphore is cleared and all pending calls are rejected.\n *    - A semaphore could not be acquired within a given time limit.\n */\nexport class SemaphoreError extends Error {\n    constructor(msg?: string) {\n        super(msg || 'Unable to acquire semaphore');\n    }\n}\n","import { LinkedQueue, Queue } from './queue';\nimport { SemaphoreError } from './semaphoreError';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link RawSemaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param semaphore - The semaphore being acquired\n */\nexport interface RawSemaphoreCallback {\n    (error: SemaphoreError | undefined, semaphore: RawSemaphore): void;\n}\n\n/**\n * Related to an [unnamed POSIX semaphore](https://man7.org/linux/man-pages/man7/sem_overview.7.html)\n */\nexport class RawSemaphore {\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    protected count: number;\n    /**\n     * The underlying queue to keep track of pending calls\n     */\n    protected queue: Queue<RawSemaphoreCallback>;\n\n    /**\n     * @param value - The initial number of calls allowed to acquire the semaphore concurrently\n     * @param queue - The underlying queue to keep track of pending calls\n     */\n    constructor(value: number, queue: Queue<RawSemaphoreCallback> = new LinkedQueue()) {\n        this.count = value;\n        this.queue = queue;\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        for (const callback of this.queue) {\n            setImmediate(callback, new SemaphoreError(), this);\n        }\n    }\n\n    /**\n     * Increment the semaphore's {@link value} by 1\n     */\n    post(): void {\n        ++this.count;\n        this.update();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns `true` and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     *\n     * Otherwise, returns `false`\n     */\n    tryWait(): boolean {\n        if (this.count < 1) {\n            return false;\n        }\n        --this.count;\n        return true;\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.count;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call acquisition is successful or rejected\n     */\n    wait(callback: RawSemaphoreCallback): void;\n    wait(callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n\n        // Add to queue\n        this.queue.enqueue(callback);\n        this.update();\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: RawSemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n        ms = ms == null ? 0 : ms;\n\n        // Setup timeout\n        let handle: NodeJS.Timeout | undefined;\n        const handler: RawSemaphoreCallback = (error, semaphore) => {\n            if (handle !== undefined) {\n                clearTimeout(handle);\n                handle = undefined;\n                callback(error, semaphore);\n            }\n        };\n        handle = setTimeout(() => handler(new SemaphoreError(), this), ms);\n\n        // Add to queue\n        this.queue.enqueue(handler);\n        this.update();\n    }\n\n    /**\n     * If the semaphore's value is above 0 and there\n     * are calls waiting, remove and unblock the head.\n     */\n    protected update(): void {\n        if (this.count > 0 && this.queue.size > 0) {\n            --this.count;\n            const callback = this.queue.dequeue()!;\n            setImmediate(callback, undefined, this);\n        }\n    }\n}\n","import { RawSemaphore } from './rawSemaphore';\n\n/**\n * Represents a lock (acquisition) on a semaphore.\n *\n * Usage imposes the following restrictions:\n * 1. A semaphore must first be acquired (locked) before it can be released (unlocked)\n * 1. If locked, the lock can be unlocked once at most\n * 1. Once unlocked, the lock is exhausted. If needed, a new lock must be acquired via the semaphore\n */\nexport class SemaphoreLock {\n    /**\n     * Whether or not the semaphore is acquired\n     */\n    protected isAcquired: boolean;\n    /**\n     * The semaphore being locked\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     *\n     * @param semaphore - The semaphore being locked\n     * @param isAcquired - Whether or not the semaphore is acquired\n     */\n    constructor(semaphore: RawSemaphore, isAcquired = true) {\n        this.semaphore = semaphore;\n        this.isAcquired = isAcquired;\n    }\n\n    /**\n     * Check if locked\n     */\n    isLocked(): boolean {\n        return this.isAcquired;\n    }\n\n    /**\n     * If locked, then unlock\n     */\n    unlock(): void {\n        if (this.isAcquired) {\n            this.isAcquired = false;\n            this.semaphore.post();\n        }\n    }\n}\n","import { RawSemaphore } from './rawSemaphore';\nimport { SemaphoreError } from './semaphoreError';\nimport { SemaphoreLock } from './semaphoreLock';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link Semaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param lock - A {@link SemaphoreLock} to the {@link Semaphore} being acquired. If acquired, the lock will be locked. Otherwise, the lock will be unlocked.\n */\nexport interface SemaphoreCallback {\n    (error: SemaphoreError | undefined, lock: SemaphoreLock): void;\n}\n\nexport class Semaphore {\n    /**\n     * The underlying raw semaphore\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     * Creates a semaphore object\n     *\n     * @param value - The max number of calls allowed to acquire the semaphore concurrently\n     */\n    constructor(value: number);\n    /**\n     * Creates a semaphore object\n     *\n     * @param semaphore - The underlying {@link RawSemaphore}\n     */\n    constructor(semaphore: RawSemaphore);\n    constructor(input: number | RawSemaphore) {\n        if (typeof input === 'number') {\n            this.semaphore = new RawSemaphore(input);\n        } else {\n            this.semaphore = input;\n        }\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        this.semaphore.clear();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns {@link SemaphoreLock} and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     * Otherwise, returns `undefined`\n     */\n    tryWait(): SemaphoreLock | undefined {\n        if (this.semaphore.tryWait()) {\n            return new SemaphoreLock(this.semaphore);\n        }\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.semaphore.value;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    wait(callback: SemaphoreCallback): void;\n    wait(callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.wait((error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: SemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.waitFor(ms, (error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n}\n","import { Semaphore } from './semaphore';\n\n/**\n * A convenience class for defining a binary {@link Semaphore} (aka `new Semaphore(1);`).\n *\n * Has the same methods as {@link Semaphore}\n */\nexport class Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\n"],"sourceRoot":""}