{"version":3,"sources":["webpack://Semafy/webpack/universalModuleDefinition","webpack://Semafy/./src/index.ts","webpack://Semafy/./src/mutex.ts","webpack://Semafy/./src/queue.ts","webpack://Semafy/./src/rawSemaphore.ts","webpack://Semafy/./src/semaphore.ts","webpack://Semafy/./src/semaphoreError.ts","webpack://Semafy/./src/semaphoreLock.ts","webpack://Semafy/webpack/bootstrap","webpack://Semafy/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","Mutex","Semaphore","super","ArrayQueue","array","this","length","value","push","size","shift","Symbol","iterator","next","done","dequeue","LinkedQueue","head","tail","undefined","node","queue","count","callback","setImmediate","SemaphoreError","update","Promise","resolve","reject","wait","err","sem","enqueue","ms","waitFor","handle","handler","error","semaphore","clearTimeout","setTimeout","input","RawSemaphore","clear","tryWait","SemaphoreLock","lock","Error","msg","isAcquired","post","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"semafy.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Semafy\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Semafy\"] = factory();\n\telse\n\t\troot[\"Semafy\"] = factory();\n})(self, function() {\nreturn ","export * from './mutex';\nexport * from './queue';\nexport * from './rawSemaphore';\nexport * from './semaphore';\nexport * from './semaphoreError';\nexport * from './semaphoreLock';\n","import { Semaphore } from './semaphore';\n\n/**\n * A convenience class for defining a binary {@link Semaphore} (aka `new Semaphore(1);`).\n *\n * Has the same methods as {@link Semaphore}\n */\nexport class Mutex extends Semaphore {\n    constructor() {\n        super(1);\n    }\n}\n","/**\n * @ignore\n */\nexport interface LinkedNode<T> {\n    next?: LinkedNode<T>;\n    value: T;\n}\n\nexport interface Queue<T> extends Iterable<T> {\n    /**\n     * Removes all elements from this queue\n     */\n    clear(): void;\n    /**\n     * Retrieves and removes the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    dequeue(): T | null;\n    /**\n     * Inserts the specified value into this queue\n     *\n     * @param value - The element to be inserted\n     *\n     * @returns `true` upon success, otherwise `false`\n     */\n    enqueue(value: T): boolean;\n    /**\n     * Retrieves, but does not remove, the head of this queue\n     *\n     * @returns The value at the head of the queue or `null` if this queue is empty.\n     */\n    peek(): T | null;\n    /**\n     * The number of elements in this queue\n     */\n    readonly size: number;\n}\n\n/**\n * @ignore\n */\nexport class ArrayQueue<T> implements Queue<T> {\n    constructor(protected array: Array<T> = []) {}\n\n    clear(): void {\n        this.array.length = 0;\n    }\n\n    enqueue(value: T): boolean {\n        this.array.push(value);\n        return true;\n    }\n\n    dequeue(): T | null {\n        return this.size < 1 ? null : this.array.shift()!;\n    }\n\n    peek(): T | null {\n        return this.size < 1 ? null : this.array[0];\n    }\n\n    get size(): number {\n        return this.array.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => (this.size < 1 ? { done: false, value: this.dequeue()! } : { done: true, value: null }),\n        };\n    }\n}\n\n/**\n * @ignore\n */\nexport class LinkedQueue<T> implements Queue<T> {\n    protected length: number;\n    protected head?: LinkedNode<T>;\n    protected tail?: LinkedNode<T>;\n\n    constructor() {\n        this.length = 0;\n    }\n\n    clear(): void {\n        this.length = 0;\n        this.head = this.tail = undefined;\n    }\n\n    dequeue(): T | null {\n        if (this.head == null) {\n            return null;\n        }\n        const node = this.head;\n        this.head = node.next;\n        if (--this.length < 1) {\n            this.tail = undefined;\n        }\n        return node.value;\n    }\n\n    enqueue(value: T): boolean {\n        const node = { value };\n        if (this.tail == null) {\n            this.head = node;\n        } else {\n            this.tail.next = node;\n        }\n        this.tail = node;\n        ++this.length;\n        return true;\n    }\n\n    peek(): T | null {\n        return this.head == null ? null : this.head.value;\n    }\n\n    get size() {\n        return this.length;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return {\n            next: () => (this.size < 1 ? { done: false, value: this.dequeue()! } : { done: true, value: null }),\n        };\n    }\n}\n","import { LinkedQueue, Queue } from './queue';\nimport { SemaphoreError } from './semaphoreError';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link RawSemaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param semaphore - The semaphore being acquired\n */\nexport interface RawSemaphoreCallback {\n    (error: SemaphoreError | undefined, semaphore: RawSemaphore): void;\n}\n\n/**\n * Related to an [unnamed POSIX semaphore](https://man7.org/linux/man-pages/man7/sem_overview.7.html)\n */\nexport class RawSemaphore {\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    protected count: number;\n    /**\n     * The underlying queue to keep track of pending calls\n     */\n    protected queue: Queue<RawSemaphoreCallback>;\n\n    /**\n     * @param value - The initial number of calls allowed to acquire the semaphore concurrently\n     * @param queue - The underlying queue to keep track of pending calls\n     */\n    constructor(value: number, queue: Queue<RawSemaphoreCallback> = new LinkedQueue()) {\n        this.count = value;\n        this.queue = queue;\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        for (const callback of this.queue) {\n            setImmediate(callback, new SemaphoreError(), this);\n        }\n    }\n\n    /**\n     * Increment the semaphore's {@link value} by 1\n     */\n    post(): void {\n        ++this.count;\n        this.update();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns `true` and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     *\n     * Otherwise, returns `false`\n     */\n    tryWait(): boolean {\n        if (this.count < 1) {\n            return false;\n        }\n        --this.count;\n        return true;\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.count;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call acquisition is successful or rejected\n     */\n    wait(callback: RawSemaphoreCallback): void;\n    wait(callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n\n        // Add to queue\n        this.queue.enqueue(callback);\n        this.update();\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<RawSemaphore>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: RawSemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: RawSemaphoreCallback | null): void | Promise<RawSemaphore> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, sem) => (err ? reject(err) : resolve(sem)));\n            });\n        }\n        ms = ms == null ? 0 : ms;\n\n        // Setup timeout\n        let handle: NodeJS.Timeout | undefined;\n        const handler: RawSemaphoreCallback = (error, semaphore) => {\n            if (handle !== undefined) {\n                clearTimeout(handle);\n                handle = undefined;\n                callback(error, semaphore);\n            }\n        };\n        handle = setTimeout(() => handler(new SemaphoreError(), this), ms);\n\n        // Add to queue\n        this.queue.enqueue(handler);\n        this.update();\n    }\n\n    /**\n     * If the semaphore's value is above 0 and there\n     * are calls waiting, remove and unblock the head.\n     */\n    protected update(): void {\n        if (this.count > 0 && this.queue.size > 0) {\n            --this.count;\n            const callback = this.queue.dequeue()!;\n            setImmediate(callback, undefined, this);\n        }\n    }\n}\n","import { RawSemaphore } from './rawSemaphore';\nimport { SemaphoreError } from './semaphoreError';\nimport { SemaphoreLock } from './semaphoreLock';\n\n/**\n * Defines the arguments to expect in a callback function passed to {@link Semaphore} methods.\n *\n * @param error - A {@link SemaphoreError} if the semaphore could not be acquired. Otherwise, this is `undefined`\n * @param lock - A {@link SemaphoreLock} to the {@link Semaphore} being acquired. If acquired, the lock will be locked. Otherwise, the lock will be unlocked.\n */\nexport interface SemaphoreCallback {\n    (error: SemaphoreError | undefined, lock: SemaphoreLock): void;\n}\n\nexport class Semaphore {\n    /**\n     * The underlying raw semaphore\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     * Creates a semaphore object\n     *\n     * @param value - The max number of calls allowed to acquire the semaphore concurrently\n     */\n    constructor(value: number);\n    /**\n     * Creates a semaphore object\n     *\n     * @param semaphore - The underlying {@link RawSemaphore}\n     */\n    constructor(semaphore: RawSemaphore);\n    constructor(input: number | RawSemaphore) {\n        if (typeof input === 'number') {\n            this.semaphore = new RawSemaphore(input);\n        } else {\n            this.semaphore = input;\n        }\n    }\n\n    /**\n     * Rejects all calls waiting for the semaphore. Rejected calls receive a {@link SemaphoreError}\n     */\n    clear(): void {\n        this.semaphore.clear();\n    }\n\n    /**\n     * Try to acquire the semaphore if immediately available.\n     *\n     * @returns {@link SemaphoreLock} and decrements the semaphore's {@link value} if the semaphore could be acquired.\n     * Otherwise, returns `undefined`\n     */\n    tryWait(): SemaphoreLock | undefined {\n        if (this.semaphore.tryWait()) {\n            return new SemaphoreLock(this.semaphore);\n        }\n    }\n\n    /**\n     * The number of calls allowed to acquire the semaphore concurrently\n     */\n    get value(): number {\n        return this.semaphore.value;\n    }\n\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     */\n    wait(callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore.\n     *\n     * If the semaphore's {@link value} is greater than zero, then the semaphore is acquired\n     * and its {@link value} is decremented. Otherwise, the call blocks until the semaphore\n     * can be acquired or the call is rejected.\n     *\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    wait(callback: SemaphoreCallback): void;\n    wait(callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.wait((err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.wait((error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     */\n    waitFor(ms?: number | null, callback?: null): Promise<SemaphoreLock>;\n    /**\n     * Acquire (lock) the semaphore within a time limit.\n     *\n     * It's the same as {@link wait | wait()} except that there's a limit on the amount of time a call\n     * can block to acquire the semaphore. If the timeout expires before the semaphore is\n     * acquired, then the call is rejected.\n     *\n     * @param ms - The maximum time (in milliseconds) to wait to acquire the semaphore. Defaults to 0\n     * @param callback - A function to call once acquisition is successful or rejected\n     */\n    waitFor(ms: number | null | undefined, callback: SemaphoreCallback): void;\n    waitFor(ms?: number | null, callback?: SemaphoreCallback | null): void | Promise<SemaphoreLock> {\n        // Sanitize inputs\n        if (callback == null) {\n            return new Promise((resolve, reject) => {\n                this.waitFor(ms, (err, lock) => (err ? reject(err) : resolve(lock!)));\n            });\n        }\n\n        // Add to semaphore\n        this.semaphore.waitFor(ms, (error, sem) => {\n            callback(error, new SemaphoreLock(sem, error == null));\n        });\n    }\n}\n","/**\n * Indicates an error when a semaphore cannot be acquired.\n *\n * This can be encountered when:\n *    - A semaphore is cleared and all pending calls are rejected.\n *    - A semaphore could not be acquired within a given time limit.\n */\nexport class SemaphoreError extends Error {\n    constructor(msg?: string) {\n        super(msg || 'Unable to acquire semaphore');\n    }\n}\n","import { SemaphoreCallback } from './semaphore';\nimport { RawSemaphore } from './rawSemaphore';\n\n/**\n * Represents a lock (acquisition) on a semaphore.\n *\n * Usage imposes the following restrictions:\n * 1. A semaphore must first be acquired (locked) before it can be released (unlocked)\n * 1. If locked, the lock can be unlocked once at most\n * 1. Once unlocked, the lock is exhausted. If needed, a new lock must be acquired via the semaphore\n */\nexport class SemaphoreLock {\n    /**\n     * Whether or not the semaphore is acquired\n     */\n    protected isAcquired: boolean;\n    /**\n     * The semaphore being locked\n     */\n    protected semaphore: RawSemaphore;\n\n    /**\n     *\n     * @param semaphore - The semaphore being locked\n     * @param isAcquired - Whether or not the semaphore is acquired\n     */\n    constructor(semaphore: RawSemaphore, isAcquired = true) {\n        this.semaphore = semaphore;\n        this.isAcquired = isAcquired;\n    }\n\n    /**\n     * Check if locked\n     */\n    isLocked(): boolean {\n        return this.isAcquired;\n    }\n\n    /**\n     * If locked, then unlock\n     */\n    unlock(): void {\n        if (this.isAcquired) {\n            this.isAcquired = false;\n            this.semaphore.post();\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"sourceRoot":""}