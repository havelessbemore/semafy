"use strict";var N=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var re=Object.getOwnPropertyNames;var oe=Object.prototype.hasOwnProperty;var ie=(o,e)=>{for(var t in e)N(o,t,{get:e[t],enumerable:!0})},se=(o,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of re(e))!oe.call(o,i)&&i!==t&&N(o,i,{get:()=>e[i],enumerable:!(r=te(e,i))||r.enumerable});return o};var ne=o=>se(N({},"__esModule",{value:!0}),o);var ae={};ie(ae,{CV_OK:()=>A,CV_TIMED_OUT:()=>p,ConditionVariable:()=>c,CountingSemaphore:()=>C,Latch:()=>V,LockError:()=>m,MultiLock:()=>U,MultiLockError:()=>k,MultiUnlockError:()=>L,Mutex:()=>d,OnceFlag:()=>P,OwnershipError:()=>a,RecursiveMutex:()=>x,RecursiveTimedMutex:()=>g,RelockError:()=>_,SharedLock:()=>M,SharedMutex:()=>E,SharedTimedMutex:()=>O,TimedMutex:()=>b,TimeoutError:()=>R,UniqueLock:()=>v,callOnce:()=>ee,lock:()=>I,lockGuard:()=>n,lockGuardSync:()=>Z,tryLock:()=>B});module.exports=ne(ae);var A="ok",p="timed-out";var D="Operation timed out",S="Value cannot be negative",T="Cannot exceed maximum value",W="Operation not permitted. Latch decrement cannot be negative",F="Operation not permitted. Latch decrement cannot exceed current count",$="Unexpected value in shared memory location",G="A lock has encountered an error",q="Operation not permitted. Lock must be acquired first",Y="Attempted relock of already acquired lock. Deadlock would occur";var K="Operation not permitted. Additional lock would exceed the maximum levels of ownership",H="Failed to acquire all locks",X="Failed to unlock all locks",Q="Operation not permitted. Semaphore release value cannot be negative",j="Operation not permitted. Semaphore release would cause overflow";var m=class extends Error{constructor(e){super(e??G),this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}};var k=class extends m{constructor(t,r,i=[],s=[],f){super(f??H);this.locks=t;this.numLocked=r;this.lockErrors=i;this.unlockErrors=s}};var L=class extends m{constructor(t,r,i=[],s){super(s??X);this.locks=t;this.numUnlocked=r;this.unlockErrors=i}};var a=class extends m{constructor(e){super(e??q)}};var _=class extends m{constructor(e){super(e??Y)}};var R=class o extends Error{deadline;timeout;constructor(e,t,r){super(e??D),this.deadline=r,this.timeout=t,this.name=o.name,Error.captureStackTrace&&Error.captureStackTrace(this,o)}};var l=1,d=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_isOwner;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._isOwner=!1,this._mem=new Int32Array(e,t,1),Atomics.and(this._mem,0,l)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._isOwner}async lock(){if(this._isOwner)throw new _;for(;Atomics.or(this._mem,0,l);){let e=Atomics.waitAsync(this._mem,0,l);e.async&&await e.value}this._isOwner=!0}lockSync(){if(this._isOwner)throw new _;for(;Atomics.or(this._mem,0,l);)Atomics.wait(this._mem,0,l);this._isOwner=!0}tryLock(){return this.tryLockSync()}tryLockSync(){return this._isOwner?!1:this._isOwner=Atomics.or(this._mem,0,l)===0}unlock(){return this.unlockSync()}unlockSync(){if(!this._isOwner)throw new a;Atomics.store(this._mem,0,0),this._isOwner=!1,Atomics.notify(this._mem,0)}};var h=1,x=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_depth;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._depth=0,this._mem=new Int32Array(e,t,1),Atomics.and(this._mem,0,h)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._depth>0}async lock(){if(this._depth===o.Max)throw new RangeError(K);if(this._depth===0)for(;Atomics.or(this._mem,0,h);)await Atomics.waitAsync(this._mem,0,h).value;++this._depth}lockSync(){if(this._depth===o.Max)throw new RangeError(K);if(this._depth===0)for(;Atomics.or(this._mem,0,h);)Atomics.wait(this._mem,0,h);++this._depth}tryLock(){return this.tryLockSync()}tryLockSync(){return this._depth===o.Max||this._depth===0&&Atomics.or(this._mem,0,h)?!1:(++this._depth,!0)}unlock(){return this.unlockSync()}unlockSync(){if(this._depth<=0)throw new a;if(this._depth>1){--this._depth;return}Atomics.store(this._mem,0,0),this._depth=0,Atomics.notify(this._mem,0)}};var J="not-equal";var w="timed-out";var g=class o extends x{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}tryLockForSync(e){return this.tryLockUntilSync(performance.now()+e)}async tryLockUntil(e){if(this._depth===o.Max)return!1;if(this._depth===0)for(;Atomics.or(this._mem,0,h);){let t=e-performance.now(),r=Atomics.waitAsync(this._mem,0,h,t);if((r.async?await r.value:r.value)===w)return!1}return++this._depth,!0}tryLockUntilSync(e){if(this._depth===o.Max)return!1;if(this._depth===0)for(;Atomics.or(this._mem,0,h);){let t=e-performance.now();if(Atomics.wait(this._mem,0,h,t)===w)return!1}return++this._depth,!0}};async function n(o,e){await o.lock();try{return await e()}finally{await o.unlock()}}function Z(o,e){o.lockSync();try{return e()}finally{o.unlockSync()}}var c=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,t,1),Atomics.store(this._mem,0,0)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}notify(e){return Atomics.notify(this._mem,0,e)}notifyAll(){return Atomics.notify(this._mem,0)}notifyOne(){return Atomics.notify(this._mem,0,1)}async wait(e){await this.waitFor(e,1/0)}async waitFor(e,t){if(!e.ownsLock)throw new a;try{let r=Atomics.waitAsync(this._mem,0,0,t);await e.unlock();let i=r.async?await r.value:r.value;if(i===J)throw new RangeError($);return i===w?p:A}finally{await e.lock()}}async waitUntil(e,t){return this.waitFor(e,t-performance.now())}};var b=class extends d{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}tryLockForSync(e){return this.tryLockUntilSync(performance.now()+e)}async tryLockUntil(e){if(this._isOwner)return!1;for(;Atomics.or(this._mem,0,l);){let t=e-performance.now(),r=Atomics.waitAsync(this._mem,0,l,t);if((r.async?await r.value:r.value)===w)return!1}return this._isOwner=!0}tryLockUntilSync(e){if(this._isOwner)return!1;for(;Atomics.or(this._mem,0,l);){let t=e-performance.now();if(Atomics.wait(this._mem,0,l,t)===w)return!1}return this._isOwner=!0}};var y=1<<31,u=~y,E=class o{static ByteLength=4*Int32Array.BYTES_PER_ELEMENT;_gate1;_gate2;_isReader;_isWriter;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;e??=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,t,4),t+=r,this._mutex=new b(e,t),t+=r,this._gate1=new c(e,t),t+=r,this._gate2=new c(e,t),this._isReader=!1,this._isWriter=!1}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._isWriter}get ownsSharedLock(){return this._isReader}async lock(){if(this._isWriter||this._isReader)throw new _;await n(this._mutex,async()=>{for(;Atomics.or(this._mem,0,y)&y;)await this._gate1.wait(this._mutex);for(this._isWriter=!0;Atomics.load(this._mem,0)&u;)await this._gate2.wait(this._mutex)})}tryLock(){if(this._isWriter||this._isReader)return!1;if(this._mutex.tryLock())try{this._isWriter=Atomics.compareExchange(this._mem,0,0,y)===0}finally{this._mutex.unlock()}return this._isWriter}async unlock(){if(!this._isWriter)throw new a;await n(this._mutex,()=>{Atomics.and(this._mem,0,u),this._isWriter=!1}),this._gate1.notifyAll()}async lockShared(){if(this._isReader||this._isWriter)throw new _;await n(this._mutex,async()=>{let e=Atomics.load(this._mem,0);for(;e&y||(e&u)===u;)await this._gate1.wait(this._mutex),e=Atomics.load(this._mem,0);Atomics.add(this._mem,0,1),this._isReader=!0})}tryLockShared(){if(this._isReader||this._isWriter)return!1;if(this._mutex.tryLock())try{let e=Atomics.load(this._mem,0);if(e&y||(e&u)===u)return!1;this._isReader=Atomics.compareExchange(this._mem,0,e,e+1)===e}finally{this._mutex.unlock()}return this._isReader}async unlockShared(){if(!this._isReader)throw new a;await n(this._mutex,()=>{let e=Atomics.sub(this._mem,0,1);this._isReader=!1,e&y?(e&u)===1&&this._gate2.notifyAll():e===u&&this._gate1.notifyAll()})}};var O=class extends E{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}async tryLockUntil(e){if(this._isWriter||this._isReader||!await this._mutex.tryLockUntil(e))return!1;let t=!1;try{for(;Atomics.or(this._mem,0,y)&y;)if(await this._gate1.waitUntil(this._mutex,e)===p)return!1;for(this._isWriter=!0;Atomics.load(this._mem,0)&u;)if(await this._gate2.waitUntil(this._mutex,e)===p)return t=!0,Atomics.and(this._mem,0,u),this._isWriter=!1,!1;return!0}finally{await this._mutex.unlock(),t&&this._gate1.notifyAll()}}async tryLockSharedFor(e){return this.tryLockSharedUntil(performance.now()+e)}async tryLockSharedUntil(e){if(this._isReader||this._isWriter||!await this._mutex.tryLockUntil(e))return!1;try{let t=Atomics.load(this._mem,0);for(;t&y||t===u;){if(await this._gate1.waitUntil(this._mutex,e)===p)return!1;t=Atomics.load(this._mem,0)}return Atomics.add(this._mem,0,1),this._isReader=!0,!0}finally{await this._mutex.unlock()}}};async function I(...o){let e=o.length,t=[],r=e;for(let s=0;s<e;++s)try{await o[s].lock()}catch(f){t.push([s,f]),r=s;break}if(r===e)return;let i=[];for(let s=r-1;s>=0;--s)try{await o[s].unlock()}catch(f){i.push([s,f])}throw new k(o,r,t,i)}async function B(...o){let e=o.length,t=[],r=e;for(let s=0;s<e;++s)try{if(!await o[s].tryLock()){r=s;break}}catch(f){t.push([s,f]),r=s;break}if(r===e)return-1;if(r<1&&t.length<1)return r;let i=[];for(let s=r-1;s>=0;--s)try{await o[s].unlock()}catch(f){i.push([s,f])}if(t.length>0)throw new k(o,r,t,i);if(i.length>0){let s=r-i.length;throw new L(o,s,i)}return r}var U=class{_isOwner;mutexes;constructor(...e){this._isOwner=!1,this.mutexes=e}get ownsLock(){return this._isOwner}async lock(){await I(...this.mutexes),this._isOwner=!0}swap(e){let t=this._isOwner;this._isOwner=e._isOwner,e._isOwner=t;let r=this.mutexes;this.mutexes=e.mutexes,e.mutexes=r}async tryLock(){let e=await B(...this.mutexes);return this._isOwner=e<0}async unlock(){let e=this.mutexes,t=e.length,r=[];for(let i=t-1;i>=0;--i)try{await e[i].unlock()}catch(s){r.push([i,s])}if(this._isOwner=!1,r.length>0){let i=t-r.length;throw new L(Array.from(e),i,r)}}};var M=class{mutex;constructor(e){this.mutex=e}get ownsLock(){return this.mutex?.ownsSharedLock??!1}lock(){return this.mutex.lockShared()}swap(e){let t=this.mutex;this.mutex=e.mutex,e.mutex=t}tryLock(){return this.mutex.tryLockShared()}tryLockFor(e){return this.mutex.tryLockSharedFor(e)}tryLockUntil(e){return this.mutex.tryLockSharedUntil(e)}unlock(){return this.mutex.unlockShared()}};var v=class{mutex;constructor(e){this.mutex=e}get ownsLock(){return this.mutex?.ownsLock??!1}lock(){return this.mutex.lock()}lockSync(){return this.mutex.lockSync()}swap(e){let t=this.mutex;this.mutex=e.mutex,e.mutex=t}tryLock(){return this.mutex.tryLock()}tryLockSync(){return this.mutex.tryLockSync()}tryLockFor(e){return this.mutex.tryLockFor(e)}tryLockForSync(e){return this.mutex.tryLockForSync(e)}tryLockUntil(e){return this.mutex.tryLockUntil(e)}tryLockUntilSync(e){return this.mutex.tryLockUntilSync(e)}unlock(){return this.mutex.unlock()}unlockSync(){return this.mutex.unlockSync()}};function ee(o,e){return o.set()?e():void 0}var P=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_bit;_bitOffset;_mem;constructor(e,t=0,r=0){if(e??=new SharedArrayBuffer(o.ByteLength),r<0)throw new RangeError("Invalid bit offset",{cause:`${r} < 0`});if(r>=32)throw new RangeError("Invalid bit offset",{cause:`${r} >= 32`});this._bit=1<<r,this._bitOffset=r,this._mem=new Int32Array(e,t,1)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get bitOffset(){return this._bitOffset}clear(){return(Atomics.and(this._mem,0,~this._bit)&this._bit)!==0}isSet(){return(Atomics.load(this._mem,0)&this._bit)!==0}set(){return(Atomics.or(this._mem,0,this._bit)&this._bit)===0}};var C=class o{static ByteLength=3*Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_gate;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;if(e instanceof SharedArrayBuffer){this._mem=new Int32Array(e,t,3),t+=r,this._mutex=new b(e,t),t+=r,this._gate=new c(e,t);return}let i=e;if(i<0)throw new RangeError(S,{cause:`${i} < 0`});if(i>o.Max)throw new RangeError(T,{cause:`${i} > ${o.Max}`});e=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,0,3),t+=r,this._mutex=new b(e,t),t+=r,this._gate=new c(e,t),this._mem[0]=i}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}acquire(){return n(this._mutex,async()=>{for(;Atomics.load(this._mem,0)<=0;)await this._gate.wait(this._mutex);Atomics.sub(this._mem,0,1)})}tryAcquire(){return n(this._mutex,()=>Atomics.load(this._mem,0)<=0?!1:(Atomics.sub(this._mem,0,1),!0))}tryAcquireFor(e){return this.tryAcquireUntil(performance.now()+e)}async tryAcquireUntil(e){if(!await this._mutex.tryLockUntil(e))return!1;try{for(;Atomics.load(this._mem,0)<=0;)if(await this._gate.waitUntil(this._mutex,e)===p)return!1;return Atomics.sub(this._mem,0,1),!0}finally{await this._mutex.unlock()}}release(e=1){if(e<0)throw new RangeError(Q,{cause:`${e} < 0`});return n(this._mutex,()=>{let t=Atomics.load(this._mem,0);if(e>o.Max-t)throw new RangeError(j,{cause:`${e} > ${o.Max-t}`});Atomics.add(this._mem,0,e),this._gate.notifyAll()})}};var V=class o{static ByteLength=3*Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_gate;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;if(e instanceof SharedArrayBuffer){this._mem=new Int32Array(e,t,3),t+=r,this._mutex=new d(e,t),t+=r,this._gate=new c(e,t);return}let i=e;if(i<0)throw new RangeError(S,{cause:`${i} < 0`});if(i>o.Max)throw new RangeError(T,{cause:`${i} > ${o.Max}`});e=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,0,3),t+=r,this._mutex=new d(e,t),t+=r,this._gate=new c(e,t),this._mem[0]=i}async countDown(e=1){if(e<0)throw new RangeError(W,{cause:`${e} < 0`});await n(this._mutex,async()=>{let t=Atomics.load(this._mem,0);if(e>t)throw new RangeError(F,{cause:`${e} > ${t}`});Atomics.sub(this._mem,0,e)===e&&this._gate.notifyAll()})}async arriveAndWait(e=1){if(e<0)throw new RangeError(W,{cause:`${e} < 0`});await n(this._mutex,async()=>{let t=Atomics.load(this._mem,0);if(e>t)throw new RangeError(F,{cause:`${e} > ${t}`});if(Atomics.sub(this._mem,0,e)===e){this._gate.notifyAll();return}do await this._gate.wait(this._mutex);while(Atomics.load(this._mem,0)!==0)})}tryWait(){return Atomics.load(this._mem,0)===0}async wait(){await n(this._mutex,async()=>{for(;Atomics.load(this._mem,0)!==0;)await this._gate.wait(this._mutex)})}};
//# sourceMappingURL=index.cjs.map