var T="ok",_="timed-out";var K="Operation timed out",A="Value cannot be negative",S="Cannot exceed maximum value",R="Operation not permitted. Latch decrement cannot be negative",g="Operation not permitted. Latch decrement cannot exceed current count",D="Unexpected value in shared memory location",$="A lock has encountered an error",G="Operation not permitted. Lock must be acquired first",q="Attempted relock of already acquired lock. Deadlock would occur";var O="Operation not permitted. Additional lock would exceed the maximum levels of ownership",Y="Failed to acquire all locks",H="Failed to unlock all locks",X="Operation not permitted. Semaphore release value cannot be negative",Q="Operation not permitted. Semaphore release would cause overflow";var u=class extends Error{constructor(e){super(e??$),this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}};var L=class extends u{constructor(t,r,i=[],s=[],p){super(p??Y);this.locks=t;this.numLocked=r;this.lockErrors=i;this.unlockErrors=s}};var w=class extends u{constructor(t,r,i=[],s){super(s??H);this.locks=t;this.numUnlocked=r;this.unlockErrors=i}};var a=class extends u{constructor(e){super(e??G)}};var f=class extends u{constructor(e){super(e??q)}};var I=class o extends Error{deadline;timeout;constructor(e,t,r){super(e??K),this.deadline=r,this.timeout=t,this.name=o.name,Error.captureStackTrace&&Error.captureStackTrace(this,o)}};var l=1,d=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_isOwner;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._isOwner=!1,this._mem=new Int32Array(e,t,1),Atomics.and(this._mem,0,l)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._isOwner}async lock(){if(this._isOwner)throw new f;for(;Atomics.or(this._mem,0,l);){let e=Atomics.waitAsync(this._mem,0,l);e.async&&await e.value}this._isOwner=!0}lockSync(){if(this._isOwner)throw new f;for(;Atomics.or(this._mem,0,l);)Atomics.wait(this._mem,0,l);this._isOwner=!0}tryLock(){return this.tryLockSync()}tryLockSync(){return this._isOwner?!1:this._isOwner=Atomics.or(this._mem,0,l)===0}unlock(){return this.unlockSync()}unlockSync(){if(!this._isOwner)throw new a;Atomics.store(this._mem,0,0),this._isOwner=!1,Atomics.notify(this._mem,0)}};var h=1,x=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_depth;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._depth=0,this._mem=new Int32Array(e,t,1),Atomics.and(this._mem,0,h)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._depth>0}async lock(){if(this._depth===o.Max)throw new RangeError(O);if(this._depth===0)for(;Atomics.or(this._mem,0,h);)await Atomics.waitAsync(this._mem,0,h).value;++this._depth}lockSync(){if(this._depth===o.Max)throw new RangeError(O);if(this._depth===0)for(;Atomics.or(this._mem,0,h);)Atomics.wait(this._mem,0,h);++this._depth}tryLock(){return this.tryLockSync()}tryLockSync(){return this._depth===o.Max||this._depth===0&&Atomics.or(this._mem,0,h)?!1:(++this._depth,!0)}unlock(){return this.unlockSync()}unlockSync(){if(this._depth<=0)throw new a;if(this._depth>1){--this._depth;return}Atomics.store(this._mem,0,0),this._depth=0,Atomics.notify(this._mem,0)}};var z="not-equal";var b="timed-out";var B=class o extends x{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}tryLockForSync(e){return this.tryLockUntilSync(performance.now()+e)}async tryLockUntil(e){if(this._depth===o.Max)return!1;if(this._depth===0)for(;Atomics.or(this._mem,0,h);){let t=e-performance.now(),r=Atomics.waitAsync(this._mem,0,h,t);if((r.async?await r.value:r.value)===b)return!1}return++this._depth,!0}tryLockUntilSync(e){if(this._depth===o.Max)return!1;if(this._depth===0)for(;Atomics.or(this._mem,0,h);){let t=e-performance.now();if(Atomics.wait(this._mem,0,h,t)===b)return!1}return++this._depth,!0}};async function n(o,e){await o.lock();try{return await e()}finally{await o.unlock()}}function J(o,e){o.lockSync();try{return e()}finally{o.unlockSync()}}var c=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_mem;constructor(e,t=0){e??=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,t,1),Atomics.store(this._mem,0,0)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}notify(e){return Atomics.notify(this._mem,0,e)}notifyAll(){return Atomics.notify(this._mem,0)}notifyOne(){return Atomics.notify(this._mem,0,1)}async wait(e){await this.waitFor(e,1/0)}async waitFor(e,t){if(!e.ownsLock)throw new a;try{let r=Atomics.waitAsync(this._mem,0,0,t);await e.unlock();let i=r.async?await r.value:r.value;if(i===z)throw new RangeError(D);return i===b?_:T}finally{await e.lock()}}async waitUntil(e,t){return this.waitFor(e,t-performance.now())}};var k=class extends d{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}tryLockForSync(e){return this.tryLockUntilSync(performance.now()+e)}async tryLockUntil(e){if(this._isOwner)return!1;for(;Atomics.or(this._mem,0,l);){let t=e-performance.now(),r=Atomics.waitAsync(this._mem,0,l,t);if((r.async?await r.value:r.value)===b)return!1}return this._isOwner=!0}tryLockUntilSync(e){if(this._isOwner)return!1;for(;Atomics.or(this._mem,0,l);){let t=e-performance.now();if(Atomics.wait(this._mem,0,l,t)===b)return!1}return this._isOwner=!0}};var y=1<<31,m=~y,E=class o{static ByteLength=4*Int32Array.BYTES_PER_ELEMENT;_gate1;_gate2;_isReader;_isWriter;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;e??=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,t,4),t+=r,this._mutex=new k(e,t),t+=r,this._gate1=new c(e,t),t+=r,this._gate2=new c(e,t),this._isReader=!1,this._isWriter=!1}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get ownsLock(){return this._isWriter}get ownsSharedLock(){return this._isReader}async lock(){if(this._isWriter||this._isReader)throw new f;await n(this._mutex,async()=>{for(;Atomics.or(this._mem,0,y)&y;)await this._gate1.wait(this._mutex);for(this._isWriter=!0;Atomics.load(this._mem,0)&m;)await this._gate2.wait(this._mutex)})}tryLock(){if(this._isWriter||this._isReader)return!1;if(this._mutex.tryLock())try{this._isWriter=Atomics.compareExchange(this._mem,0,0,y)===0}finally{this._mutex.unlock()}return this._isWriter}async unlock(){if(!this._isWriter)throw new a;await n(this._mutex,()=>{Atomics.and(this._mem,0,m),this._isWriter=!1}),this._gate1.notifyAll()}async lockShared(){if(this._isReader||this._isWriter)throw new f;await n(this._mutex,async()=>{let e=Atomics.load(this._mem,0);for(;e&y||(e&m)===m;)await this._gate1.wait(this._mutex),e=Atomics.load(this._mem,0);Atomics.add(this._mem,0,1),this._isReader=!0})}tryLockShared(){if(this._isReader||this._isWriter)return!1;if(this._mutex.tryLock())try{let e=Atomics.load(this._mem,0);if(e&y||(e&m)===m)return!1;this._isReader=Atomics.compareExchange(this._mem,0,e,e+1)===e}finally{this._mutex.unlock()}return this._isReader}async unlockShared(){if(!this._isReader)throw new a;await n(this._mutex,()=>{let e=Atomics.sub(this._mem,0,1);this._isReader=!1,e&y?(e&m)===1&&this._gate2.notifyAll():e===m&&this._gate1.notifyAll()})}};var U=class extends E{async tryLockFor(e){return this.tryLockUntil(performance.now()+e)}async tryLockUntil(e){if(this._isWriter||this._isReader||!await this._mutex.tryLockUntil(e))return!1;let t=!1;try{for(;Atomics.or(this._mem,0,y)&y;)if(await this._gate1.waitUntil(this._mutex,e)===_)return!1;for(this._isWriter=!0;Atomics.load(this._mem,0)&m;)if(await this._gate2.waitUntil(this._mutex,e)===_)return t=!0,Atomics.and(this._mem,0,m),this._isWriter=!1,!1;return!0}finally{await this._mutex.unlock(),t&&this._gate1.notifyAll()}}async tryLockSharedFor(e){return this.tryLockSharedUntil(performance.now()+e)}async tryLockSharedUntil(e){if(this._isReader||this._isWriter||!await this._mutex.tryLockUntil(e))return!1;try{let t=Atomics.load(this._mem,0);for(;t&y||t===m;){if(await this._gate1.waitUntil(this._mutex,e)===_)return!1;t=Atomics.load(this._mem,0)}return Atomics.add(this._mem,0,1),this._isReader=!0,!0}finally{await this._mutex.unlock()}}};async function M(...o){let e=o.length,t=[],r=e;for(let s=0;s<e;++s)try{await o[s].lock()}catch(p){t.push([s,p]),r=s;break}if(r===e)return;let i=[];for(let s=r-1;s>=0;--s)try{await o[s].unlock()}catch(p){i.push([s,p])}throw new L(o,r,t,i)}async function v(...o){let e=o.length,t=[],r=e;for(let s=0;s<e;++s)try{if(!await o[s].tryLock()){r=s;break}}catch(p){t.push([s,p]),r=s;break}if(r===e)return-1;if(r<1&&t.length<1)return r;let i=[];for(let s=r-1;s>=0;--s)try{await o[s].unlock()}catch(p){i.push([s,p])}if(t.length>0)throw new L(o,r,t,i);if(i.length>0){let s=r-i.length;throw new w(o,s,i)}return r}var P=class{_isOwner;mutexes;constructor(...e){this._isOwner=!1,this.mutexes=e}get ownsLock(){return this._isOwner}async lock(){await M(...this.mutexes),this._isOwner=!0}swap(e){let t=this._isOwner;this._isOwner=e._isOwner,e._isOwner=t;let r=this.mutexes;this.mutexes=e.mutexes,e.mutexes=r}async tryLock(){let e=await v(...this.mutexes);return this._isOwner=e<0}async unlock(){let e=this.mutexes,t=e.length,r=[];for(let i=t-1;i>=0;--i)try{await e[i].unlock()}catch(s){r.push([i,s])}if(this._isOwner=!1,r.length>0){let i=t-r.length;throw new w(Array.from(e),i,r)}}};var C=class{mutex;constructor(e){this.mutex=e}get ownsLock(){return this.mutex?.ownsSharedLock??!1}lock(){return this.mutex.lockShared()}swap(e){let t=this.mutex;this.mutex=e.mutex,e.mutex=t}tryLock(){return this.mutex.tryLockShared()}tryLockFor(e){return this.mutex.tryLockSharedFor(e)}tryLockUntil(e){return this.mutex.tryLockSharedUntil(e)}unlock(){return this.mutex.unlockShared()}};var V=class{mutex;constructor(e){this.mutex=e}get ownsLock(){return this.mutex?.ownsLock??!1}lock(){return this.mutex.lock()}lockSync(){return this.mutex.lockSync()}swap(e){let t=this.mutex;this.mutex=e.mutex,e.mutex=t}tryLock(){return this.mutex.tryLock()}tryLockSync(){return this.mutex.tryLockSync()}tryLockFor(e){return this.mutex.tryLockFor(e)}tryLockForSync(e){return this.mutex.tryLockForSync(e)}tryLockUntil(e){return this.mutex.tryLockUntil(e)}tryLockUntilSync(e){return this.mutex.tryLockUntilSync(e)}unlock(){return this.mutex.unlock()}unlockSync(){return this.mutex.unlockSync()}};function Z(o,e){return o.set()?e():void 0}var N=class o{static ByteLength=Int32Array.BYTES_PER_ELEMENT;_bit;_bitOffset;_mem;constructor(e,t=0,r=0){if(e??=new SharedArrayBuffer(o.ByteLength),r<0)throw new RangeError("Invalid bit offset",{cause:`${r} < 0`});if(r>=32)throw new RangeError("Invalid bit offset",{cause:`${r} >= 32`});this._bit=1<<r,this._bitOffset=r,this._mem=new Int32Array(e,t,1)}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}get bitOffset(){return this._bitOffset}clear(){return(Atomics.and(this._mem,0,~this._bit)&this._bit)!==0}isSet(){return(Atomics.load(this._mem,0)&this._bit)!==0}set(){return(Atomics.or(this._mem,0,this._bit)&this._bit)===0}};var W=class o{static ByteLength=3*Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_gate;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;if(e instanceof SharedArrayBuffer){this._mem=new Int32Array(e,t,3),t+=r,this._mutex=new k(e,t),t+=r,this._gate=new c(e,t);return}let i=e;if(i<0)throw new RangeError(A,{cause:`${i} < 0`});if(i>o.Max)throw new RangeError(S,{cause:`${i} > ${o.Max}`});e=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,0,3),t+=r,this._mutex=new k(e,t),t+=r,this._gate=new c(e,t),this._mem[0]=i}get buffer(){return this._mem.buffer}get byteLength(){return this._mem.byteLength}get byteOffset(){return this._mem.byteOffset}acquire(){return n(this._mutex,async()=>{for(;Atomics.load(this._mem,0)<=0;)await this._gate.wait(this._mutex);Atomics.sub(this._mem,0,1)})}tryAcquire(){return n(this._mutex,()=>Atomics.load(this._mem,0)<=0?!1:(Atomics.sub(this._mem,0,1),!0))}tryAcquireFor(e){return this.tryAcquireUntil(performance.now()+e)}async tryAcquireUntil(e){if(!await this._mutex.tryLockUntil(e))return!1;try{for(;Atomics.load(this._mem,0)<=0;)if(await this._gate.waitUntil(this._mutex,e)===_)return!1;return Atomics.sub(this._mem,0,1),!0}finally{await this._mutex.unlock()}}release(e=1){if(e<0)throw new RangeError(X,{cause:`${e} < 0`});return n(this._mutex,()=>{let t=Atomics.load(this._mem,0);if(e>o.Max-t)throw new RangeError(Q,{cause:`${e} > ${o.Max-t}`});Atomics.add(this._mem,0,e),this._gate.notifyAll()})}};var F=class o{static ByteLength=3*Int32Array.BYTES_PER_ELEMENT;static Max=2147483647;_gate;_mem;_mutex;constructor(e,t=0){let r=Int32Array.BYTES_PER_ELEMENT;if(e instanceof SharedArrayBuffer){this._mem=new Int32Array(e,t,3),t+=r,this._mutex=new d(e,t),t+=r,this._gate=new c(e,t);return}let i=e;if(i<0)throw new RangeError(A,{cause:`${i} < 0`});if(i>o.Max)throw new RangeError(S,{cause:`${i} > ${o.Max}`});e=new SharedArrayBuffer(o.ByteLength),this._mem=new Int32Array(e,0,3),t+=r,this._mutex=new d(e,t),t+=r,this._gate=new c(e,t),this._mem[0]=i}async countDown(e=1){if(e<0)throw new RangeError(R,{cause:`${e} < 0`});await n(this._mutex,async()=>{let t=Atomics.load(this._mem,0);if(e>t)throw new RangeError(g,{cause:`${e} > ${t}`});Atomics.sub(this._mem,0,e)===e&&this._gate.notifyAll()})}async arriveAndWait(e=1){if(e<0)throw new RangeError(R,{cause:`${e} < 0`});await n(this._mutex,async()=>{let t=Atomics.load(this._mem,0);if(e>t)throw new RangeError(g,{cause:`${e} > ${t}`});if(Atomics.sub(this._mem,0,e)===e){this._gate.notifyAll();return}do await this._gate.wait(this._mutex);while(Atomics.load(this._mem,0)!==0)})}tryWait(){return Atomics.load(this._mem,0)===0}async wait(){await n(this._mutex,async()=>{for(;Atomics.load(this._mem,0)!==0;)await this._gate.wait(this._mutex)})}};export{T as CV_OK,_ as CV_TIMED_OUT,c as ConditionVariable,W as CountingSemaphore,F as Latch,u as LockError,P as MultiLock,L as MultiLockError,w as MultiUnlockError,d as Mutex,N as OnceFlag,a as OwnershipError,x as RecursiveMutex,B as RecursiveTimedMutex,f as RelockError,C as SharedLock,E as SharedMutex,U as SharedTimedMutex,k as TimedMutex,I as TimeoutError,V as UniqueLock,Z as callOnce,M as lock,n as lockGuard,J as lockGuardSync,v as tryLock};
//# sourceMappingURL=index.js.map