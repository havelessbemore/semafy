{"version":3,"sources":["../../src/types/cvStatus.ts","../../src/errors/constants.ts","../../src/errors/lockError.ts","../../src/errors/multiLockError.ts","../../src/errors/multiUnlockError.ts","../../src/errors/ownershipError.ts","../../src/errors/relockError.ts","../../src/errors/timeoutError.ts","../../src/mutexes/mutex.ts","../../src/mutexes/recursiveMutex.ts","../../src/types/atomicsStatus.ts","../../src/mutexes/recursiveTimedMutex.ts","../../src/locks/lockGuard.ts","../../src/condVars/conditionVariable.ts","../../src/mutexes/timedMutex.ts","../../src/mutexes/sharedMutex.ts","../../src/mutexes/sharedTimedMutex.ts","../../src/locks/lock.ts","../../src/locks/tryLock.ts","../../src/locks/multiLock.ts","../../src/locks/sharedLock.ts","../../src/locks/uniqueLock.ts","../../src/callOnce/callOnce.ts","../../src/callOnce/onceFlag.ts","../../src/semaphores/countingSemaphore.ts","../../src/barriers/latch.ts"],"sourcesContent":["/**\n * Represents the possible status codes\n * returned by {@link ConditionVariable} operations.\n */\nexport type CVStatus = typeof CV_OK | typeof CV_TIMED_OUT;\n\n/**\n * The {@link ConditionVariable} was awakened via notification.\n */\nexport const CV_OK = \"ok\";\n\n/**\n * The {@link ConditionVariable} was awakened by timeout expiration.\n */\nexport const CV_TIMED_OUT = \"timed-out\";\n","// Generic\nexport const ERR_TIMEOUT = \"Operation timed out\";\n\nexport const ERR_NEGATIVE_VALUE = \"Value cannot be negative\";\n\nexport const ERR_OVERFLOW = \"Cannot exceed maximum value\";\n\n// Barriers\n\nexport const ERR_LATCH_INPUT_UNDERFLOW =\n  \"Operation not permitted. Latch decrement cannot be negative\";\n\nexport const ERR_LATCH_INPUT_OVERFLOW =\n  \"Operation not permitted. Latch decrement cannot exceed current count\";\n\n// Condition Variable\nexport const ERR_CV_VALUE = \"Unexpected value in shared memory location\";\n\n// Mutex\nexport const ERR_LOCK = \"A lock has encountered an error\";\n\nexport const ERR_LOCK_OWNERSHIP =\n  \"Operation not permitted. Lock must be acquired first\";\n\nexport const ERR_LOCK_RELOCK =\n  \"Attempted relock of already acquired lock. Deadlock would occur\";\n\nexport const ERR_LOCK_TIMEOUT = \"Timed out acquiring lock\";\n\n// Recursive Mutex\n\nexport const ERR_REC_MUTEX_OVERFLOW =\n  \"Operation not permitted. Additional lock would exceed the maximum levels of ownership\";\n\n// Mutex Management\nexport const ERR_MULTI_LOCK = \"Failed to acquire all locks\";\n\nexport const ERR_MULTI_UNLOCK = \"Failed to unlock all locks\";\n\n// Semaphore\nexport const ERR_SEM_INPUT_NEG =\n  \"Operation not permitted. Semaphore release value cannot be negative\";\n\nexport const ERR_SEM_INPUT_OVERFLOW =\n  \"Operation not permitted. Semaphore release would cause overflow\";\n","import { ERR_LOCK } from \"./constants\";\n\n/**\n * Represents a generic error originating from a lock.\n */\nexport class LockError extends Error {\n  /**\n   * @param message - An optional custom error message.\n   */\n  constructor(message?: string) {\n    super(message ?? ERR_LOCK);\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import type { BasicLockable } from \"../types/basicLockable\";\n\nimport { ERR_MULTI_LOCK } from \"./constants\";\nimport { LockError } from \"./lockError\";\n\n/**\n * Represents an error that occurs when attempting to lock multiple {@link BasicLockable} objects simultaneously.\n *\n * This error provides detailed information about the failure of locking operations, including specifics\n * about any errors that occurred. It ensures that any partial state due to errors can be adequately handled.\n */\nexport class MultiLockError extends LockError {\n  /**\n   * @param locks - The array of all lockable objects that were part of the operation.\n   * @param numLocked - The number of locks successfully updated before failure.\n   * @param lockErrors - An array of [index, error] pairs that contain the index of the lock in\n   * the `locks` array and the error that occurred while attempting to lock it. Useful for\n   * understanding why lock acquisition failed.\n   * @param unlockErrors - An array of [index, error] pairs that contain the index of the lock in\n   * the `locks` array and the error that occurred while attempting rollback. Useful for\n   * debugging unexpected issues during unlocking.\n   * @param message - An optional custom error message that describes the error.\n   */\n  constructor(\n    public locks: BasicLockable[],\n    public numLocked: number,\n    public lockErrors: [number, unknown][] = [],\n    public unlockErrors: [number, unknown][] = [],\n    message?: string,\n  ) {\n    super(message ?? ERR_MULTI_LOCK);\n  }\n}\n","import type { BasicLockable } from \"../types/basicLockable\";\n\nimport { ERR_MULTI_UNLOCK } from \"./constants\";\nimport { LockError } from \"./lockError\";\n\n/**\n * Represents an error that occurs when attempting to unlock multiple {@link BasicLockable} objects simultaneously.\n *\n * This error provides detailed information about the failure of unlocking operations, including specifics\n * about any errors that occurred. It ensures that any partial state due to errors can be adequately handled.\n */\nexport class MultiUnlockError extends LockError {\n  /**\n   * @param locks - The array of all lockable objects that were part of the operation.\n   * @param numUnlocked - The number of unlocks successfully updated before failure.\n   * @param unlockErrors - An array of [index, error] pairs that contain the index of the lock in\n   * the `locks` array and the error that occurred while attempting to unlock it. Useful for\n   * debugging unexpected issues during unlocking.\n   * @param message - An optional custom error message that describes the error.\n   */\n  constructor(\n    public locks: BasicLockable[],\n    public numUnlocked: number,\n    public unlockErrors: [number, unknown][] = [],\n    message?: string,\n  ) {\n    super(message ?? ERR_MULTI_UNLOCK);\n  }\n}\n","import { ERR_LOCK_OWNERSHIP } from \"./constants\";\nimport { LockError } from \"./lockError\";\n\n/**\n * Represents an ownership error originating from a lock.\n */\nexport class OwnershipError extends LockError {\n  /**\n   * @param message - An optional custom error message.\n   */\n  constructor(message?: string) {\n    super(message ?? ERR_LOCK_OWNERSHIP);\n  }\n}\n","import { ERR_LOCK_RELOCK } from \"./constants\";\nimport { LockError } from \"./lockError\";\n\n/**\n * Represents an error relocking a lock.\n */\nexport class RelockError extends LockError {\n  /**\n   * @param message - An optional custom error message.\n   */\n  constructor(message?: string) {\n    super(message ?? ERR_LOCK_RELOCK);\n  }\n}\n","import { ERR_TIMEOUT } from \"./constants\";\n\n/**\n * Represents an error that occurs when a process exceeds a set time.\n */\nexport class TimeoutError extends Error {\n  /**\n   * Absolute time in milliseconds after which the timeout error was thrown.\n   * Can be `undefined` if not specified.\n   */\n  deadline?: number;\n\n  /**\n   * Duration in milliseconds after which the timeout error was thrown.\n   * Can be `undefined` if not specified.\n   */\n  timeout?: number;\n\n  /**\n   * @param message - A custom error message. Defaults to `undefined`.\n   * @param timeout - The timeout duration in milliseconds. Defaults to `undefined`.\n   * @param deadline - The absolute time in milliseconds. Defaults to `undefined`.\n   */\n  constructor(message?: string, timeout?: number, deadline?: number) {\n    super(message ?? ERR_TIMEOUT);\n    this.deadline = deadline;\n    this.timeout = timeout;\n    this.name = TimeoutError.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TimeoutError);\n    }\n  }\n}\n","import type { Lockable } from \"../types/lockable\";\nimport type { SharedResource } from \"../types/sharedResource\";\nimport type { SyncLockable } from \"../types/sync/syncLockable\";\n\nimport { OwnershipError } from \"../errors/ownershipError\";\nimport { RelockError } from \"../errors/relockError\";\n\n/**\n * Represents the mutex lock state.\n */\nexport const LOCK_BIT = 1;\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive access to shared resources / blocks of code.\n *\n * A mutex is owned from the time an agent successfully locks it\n * and until the agent unlocks it. During ownership, any other agents\n * attempting to lock the mutex will block (or receive `false` from\n * `tryLock` methods). When unlocked, any blocked agent will have\n * the chance to acquire owernship.\n *\n * A locked mutex should not be relocked by the owner. Attempts\n * for additional locks will throw an error, and calls to `tryLock`\n * methods will return `false`.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/mutex | C++ std::mutex}\n */\nexport class Mutex implements Lockable, SyncLockable, SharedResource {\n  /**\n   * The size in bytes of the mutex.\n   */\n  static readonly ByteLength = Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * Indicates whether the current agent owns the lock.\n   */\n  protected _isOwner: boolean;\n\n  /**\n   * The shared memory for the mutex.\n   */\n  protected _mem: Int32Array;\n\n  constructor();\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the mutex.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer?: SharedArrayBuffer, byteOffset = 0) {\n    // Sanitize input\n    sharedBuffer ??= new SharedArrayBuffer(Mutex.ByteLength);\n\n    // Initialize properties\n    this._isOwner = false;\n    this._mem = new Int32Array(sharedBuffer, byteOffset, 1);\n\n    // Initialize shared memory location\n    Atomics.and(this._mem, 0, LOCK_BIT);\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  get ownsLock(): boolean {\n    return this._isOwner;\n  }\n\n  /**\n   * @throws A {@link RelockError} If the lock is already locked by the caller.\n   */\n  async lock(): Promise<void> {\n    // If already has lock\n    if (this._isOwner) {\n      throw new RelockError();\n    }\n\n    // Acquire lock\n    while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n      const res = Atomics.waitAsync(this._mem, 0, LOCK_BIT);\n      if (res.async) {\n        await res.value;\n      }\n    }\n    this._isOwner = true;\n  }\n\n  /**\n   * @throws A {@link RelockError} If the lock is already locked by the caller.\n   */\n  lockSync(): void {\n    // If already has lock\n    if (this._isOwner) {\n      throw new RelockError();\n    }\n\n    // Acquire lock\n    while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n      Atomics.wait(this._mem, 0, LOCK_BIT);\n    }\n    this._isOwner = true;\n  }\n\n  tryLock(): boolean {\n    return this.tryLockSync();\n  }\n\n  tryLockSync(): boolean {\n    // If already has lock\n    if (this._isOwner) {\n      return false;\n    }\n    // Try to acquire lock\n    return (this._isOwner = Atomics.or(this._mem, 0, LOCK_BIT) === 0);\n  }\n\n  /**\n   * @throws An {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  unlock(): void {\n    return this.unlockSync();\n  }\n\n  /**\n   * @throws An {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  unlockSync(): void {\n    // Check if lock owned\n    if (!this._isOwner) {\n      throw new OwnershipError();\n    }\n    // Release lock\n    Atomics.store(this._mem, 0, 0);\n    this._isOwner = false;\n    // Notify blocked agents\n    Atomics.notify(this._mem, 0);\n  }\n}\n","import type { Lockable } from \"../types/lockable\";\nimport type { SharedResource } from \"../types/sharedResource\";\nimport type { SyncLockable } from \"../types/sync/syncLockable\";\n\nimport { ERR_REC_MUTEX_OVERFLOW } from \"../errors/constants\";\nimport { OwnershipError } from \"../errors/ownershipError\";\nimport { MAX_INT32_VALUE } from \"../utils/constants\";\n\n/**\n * Represents the mutex lock state.\n */\nexport const LOCK_BIT = 1;\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive recursive access to shared resources / blocks of code.\n *\n * A mutex is owned once an agent successfully locks it.\n * During ownership, the agent may acquire additional locks from the\n * mutex. Ownership ends when the agent releases all aquired locks.\n *\n * While owned, any other agents attempting to lock the mutex will\n * block (or receive `false` from `tryLock` methods). When unlocked,\n * any blocked agent will have the chance to acquire owernship.\n *\n * The maximum number of times a mutex can be locked recursively\n * is defined by {@link RecursiveMutex.Max}. Once reached, attempts\n * for additional locks will throw an error, and calls to `tryLock` methods\n * will return `false`.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/recursive_mutex | C++ std::recursive_mutex}\n */\nexport class RecursiveMutex implements Lockable, SyncLockable, SharedResource {\n  /**\n   * The size in bytes of the mutex.\n   */\n  static readonly ByteLength = Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * The maximum levels of recursive ownership.\n   */\n  static readonly Max = MAX_INT32_VALUE;\n\n  /**\n   * The number of locks acquired by the agent.\n   */\n  protected _depth: number;\n\n  /**\n   * The shared atomic memory for the mutex.\n   */\n  protected _mem: Int32Array;\n\n  constructor();\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the mutex.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer?: SharedArrayBuffer, byteOffset = 0) {\n    // Sanitize input\n    sharedBuffer ??= new SharedArrayBuffer(RecursiveMutex.ByteLength);\n\n    // Initialize properties\n    this._depth = 0;\n    this._mem = new Int32Array(sharedBuffer, byteOffset, 1);\n\n    // Initialize shared memory location\n    Atomics.and(this._mem, 0, LOCK_BIT);\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  get ownsLock(): boolean {\n    return this._depth > 0;\n  }\n\n  /**\n   * @throws A {@link RangeError} If the mutex is already locked the maximum amount of times.\n   */\n  async lock(): Promise<void> {\n    // If at capacity\n    if (this._depth === RecursiveMutex.Max) {\n      throw new RangeError(ERR_REC_MUTEX_OVERFLOW);\n    }\n\n    // Acquire lock if not owned\n    if (this._depth === 0) {\n      while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n        await Atomics.waitAsync(this._mem, 0, LOCK_BIT).value;\n      }\n    }\n\n    // Increment ownership\n    ++this._depth;\n  }\n\n  /**\n   * @throws A {@link RangeError} If the mutex is already locked the maximum amount of times.\n   */\n  lockSync(): void {\n    // If at capacity\n    if (this._depth === RecursiveMutex.Max) {\n      throw new RangeError(ERR_REC_MUTEX_OVERFLOW);\n    }\n\n    // Acquire lock if not owned\n    if (this._depth === 0) {\n      while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n        Atomics.wait(this._mem, 0, LOCK_BIT);\n      }\n    }\n\n    // Increment ownership\n    ++this._depth;\n  }\n\n  tryLock(): boolean {\n    return this.tryLockSync();\n  }\n\n  tryLockSync(): boolean {\n    // If at capacity\n    if (this._depth === RecursiveMutex.Max) {\n      return false;\n    }\n\n    // Try to acquire lock if not owned\n    if (this._depth === 0 && Atomics.or(this._mem, 0, LOCK_BIT)) {\n      return false;\n    }\n\n    // Increment ownership\n    ++this._depth;\n    return true;\n  }\n\n  /**\n   * @throws A {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  unlock(): void {\n    return this.unlockSync();\n  }\n\n  /**\n   * @throws A {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  unlockSync(): void {\n    // Check if lock owned\n    if (this._depth <= 0) {\n      throw new OwnershipError();\n    }\n\n    // Check if lock owned recursively\n    if (this._depth > 1) {\n      --this._depth;\n      return;\n    }\n\n    // Release lock\n    Atomics.store(this._mem, 0, 0);\n    this._depth = 0;\n\n    // Notify blocked agents\n    Atomics.notify(this._mem, 0);\n  }\n}\n","/**\n * Represents the possible status codes returned by {@link Atomics} operations.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics| Atomics}\n */\nexport type AtomicsStatus =\n  | typeof ATOMICS_NOT_EQUAL\n  | typeof ATOMICS_OK\n  | typeof ATOMICS_TIMED_OUT;\n\n/**\n * Indicates that the expected value was not found at the atomic location.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync | Atomics}\n */\nexport const ATOMICS_NOT_EQUAL = \"not-equal\";\n\n/**\n * Indicates the {@link Atomics} operation completed successfully.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics | Atomics}\n */\nexport const ATOMICS_OK = \"ok\";\n\n/**\n * Indicates the {@link Atomics} operation\n * did not complete within the given time.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync | Atomics}\n */\nexport const ATOMICS_TIMED_OUT = \"timed-out\";\n","import { ATOMICS_TIMED_OUT } from \"../types/atomicsStatus\";\nimport type { SyncTimedLockable } from \"../types/sync/syncTimedLockable\";\nimport type { TimedLockable } from \"../types/timedLockable\";\n\nimport { LOCK_BIT, RecursiveMutex } from \"./recursiveMutex\";\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive recursive access to shared resources / blocks of code.\n *\n * A mutex is owned once an agent successfully locks it.\n * During ownership, the agent may acquire additional locks from the\n * mutex. Ownership ends when the agent releases all aquired locks.\n *\n * While owned, any other agents attempting to lock the mutex will\n * block (or receive `false` from `tryLock` methods). When unlocked,\n * any blocked agent will have the chance to acquire owernship.\n *\n * The maximum number of times a mutex can be locked recursively\n * is defined by {@link RecursiveTimedMutex.Max}. Once reached, attempts\n * for additional locks will throw an error, and calls to `tryLock` methods\n * will return `false`.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * Timeout precision for time-based methods may vary due to system load\n * and inherent limitations of JavaScript timing. Developers should\n * consider this possible variability in their applications.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/recursive_mutex | C++ std::recursive_mutex}\n */\nexport class RecursiveTimedMutex\n  extends RecursiveMutex\n  implements TimedLockable, SyncTimedLockable\n{\n  async tryLockFor(timeout: number): Promise<boolean> {\n    return this.tryLockUntil(performance.now() + timeout);\n  }\n\n  tryLockForSync(timeout: number): boolean {\n    return this.tryLockUntilSync(performance.now() + timeout);\n  }\n\n  async tryLockUntil(timestamp: number): Promise<boolean> {\n    // If at capacity\n    if (this._depth === RecursiveTimedMutex.Max) {\n      return false;\n    }\n\n    // If not owned, try to acquire lock for a given amount of time\n    if (this._depth === 0) {\n      while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n        const timeout = timestamp - performance.now();\n        const res = Atomics.waitAsync(this._mem, 0, LOCK_BIT, timeout);\n        const value = res.async ? await res.value : res.value;\n        // If time expired\n        if (value === ATOMICS_TIMED_OUT) {\n          return false;\n        }\n      }\n    }\n\n    // Increment ownership\n    ++this._depth;\n    return true;\n  }\n\n  tryLockUntilSync(timestamp: number): boolean {\n    // If at capacity\n    if (this._depth === RecursiveTimedMutex.Max) {\n      return false;\n    }\n\n    // If not owned, try to acquire lock for a given amount of time\n    if (this._depth === 0) {\n      while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n        const timeout = timestamp - performance.now();\n        const value = Atomics.wait(this._mem, 0, LOCK_BIT, timeout);\n        // If time expired\n        if (value === ATOMICS_TIMED_OUT) {\n          return false;\n        }\n      }\n    }\n\n    // Increment ownership\n    ++this._depth;\n    return true;\n  }\n}\n","import type { BasicLockable } from \"../types/basicLockable\";\nimport type { SyncBasicLockable } from \"../types/sync/syncBasicLockable\";\n\n/**\n * Acquires the mutex and executes the provided callback, automatically\n * unlocking afterwards. Blocks until the lock is available.\n *\n * @param mutex The mutex to acquire.\n * @param callbackfn The callback function.\n *\n * @returns A promise resolved to the return value of `callbackfn`.\n */\nexport async function lockGuard<T>(\n  mutex: BasicLockable,\n  callbackfn: () => T | Promise<T>,\n): Promise<T> {\n  // Acquire lock\n  await mutex.lock();\n  try {\n    // Execute callback\n    return await callbackfn();\n  } finally {\n    // Release lock\n    await mutex.unlock();\n  }\n}\n\n/**\n * Acquires the mutex and executes the provided callback, automatically\n * unlocking afterwards. Blocks until the lock is available.\n *\n * @param mutex The mutex to acquire.\n * @param callbackfn The callback function.\n *\n * @returns The return value of `callbackfn`.\n */\nexport function lockGuardSync<T>(\n  mutex: SyncBasicLockable,\n  callbackfn: () => T,\n): T {\n  // Acquire lock\n  mutex.lockSync();\n  try {\n    // Execute callback\n    return callbackfn();\n  } finally {\n    // Release lock\n    mutex.unlockSync();\n  }\n}\n","import { ATOMICS_NOT_EQUAL, ATOMICS_TIMED_OUT } from \"../types/atomicsStatus\";\nimport type { BasicLockable } from \"../types/basicLockable\";\nimport { type CVStatus, CV_OK, CV_TIMED_OUT } from \"../types/cvStatus\";\nimport type { SharedResource } from \"../types/sharedResource\";\n\nimport { ERR_CV_VALUE } from \"../errors/constants\";\nimport { OwnershipError } from \"../errors/ownershipError\";\n\n/**\n * A condition variable manages an atomic wait/block mechanism that\n * is tightly coupled with a mutex for safe cross-agent synchronization.\n *\n * Behavior is undefined if:\n *    - The shared memory location is modified externally.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/condition_variable | C++ std::condition_variable}\n * 1. {@link https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html | Alexander Terekhov, Howard Hinnant. (2007-09-09). Mutex, Lock, Condition Variable Rationale}\n */\nexport class ConditionVariable implements SharedResource {\n  /**\n   * The size in bytes of the condition variable.\n   */\n  static readonly ByteLength = Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * The shared atomic memory where the condition variable stores its state.\n   */\n  private _mem: Int32Array;\n\n  constructor();\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the condition variable.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer?: SharedArrayBuffer, byteOffset = 0) {\n    // Sanitize input\n    sharedBuffer ??= new SharedArrayBuffer(ConditionVariable.ByteLength);\n\n    // Initialize properties\n    this._mem = new Int32Array(sharedBuffer, byteOffset, 1);\n\n    // Initialize shared memory location\n    Atomics.store(this._mem, 0, 0);\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  /**\n   * Notify waiting agents that are blocked on this condition variable.\n   *\n   * @param count - The number of agents to notify.\n   *\n   * @returns The number of agents that were notified.\n   */\n  notify(count: number): number {\n    return Atomics.notify(this._mem, 0, count);\n  }\n\n  /**\n   * Notify all waiting agents that are blocked on this condition variable.\n   *\n   * @returns The number of agents that were notified.\n   */\n  notifyAll(): number {\n    return Atomics.notify(this._mem, 0);\n  }\n\n  /**\n   * Notify one waiting agent that is blocked on this condition variable.\n   *\n   * @returns The number of agents that were notified.\n   */\n  notifyOne(): number {\n    return Atomics.notify(this._mem, 0, 1);\n  }\n\n  /**\n   * Blocks the current agent until this condition variable is notified.\n   * The associated mutex is released before blocking and re-acquired\n   * after waking up.\n   *\n   * @param mutex The mutex that must be locked by the current agent.\n   *\n   * @throws An {@link OwnershipError} If the mutex is not owned by the caller.\n   * @throws A {@link RangeError} If the shared memory data is unexpected.\n   */\n  async wait(mutex: BasicLockable): Promise<void> {\n    await this.waitFor(mutex, Infinity);\n  }\n\n  /**\n   * Blocks the current agent until this condition variable is notified,\n   * or an optional timeout expires. The associated mutex is released\n   * before blocking and re-acquired after waking up.\n   *\n   * @param mutex The mutex that must be locked by the current agent.\n   * @param timeout A timeout in milliseconds after which the wait is aborted.\n   *\n   * @throws An {@link OwnershipError} If the mutex is not owned by the caller.\n   * @throws A {@link RangeError} If the shared memory data is unexpected.\n   *\n   * @returns A {@link CVStatus} representing the result of the operation.\n   */\n  async waitFor(mutex: BasicLockable, timeout: number): Promise<CVStatus> {\n    // Check mutex is owned\n    if (!mutex.ownsLock) {\n      throw new OwnershipError();\n    }\n    try {\n      // Start waiting BEFORE releasing mutex\n      const res = Atomics.waitAsync(this._mem, 0, 0, timeout);\n      // Release mutex\n      await mutex.unlock();\n      // Wait for notification\n      const value = res.async ? await res.value : res.value;\n      // Check for unexpected value at shared memory location\n      if (value === ATOMICS_NOT_EQUAL) {\n        throw new RangeError(ERR_CV_VALUE);\n      }\n      // Return status\n      return value === ATOMICS_TIMED_OUT ? CV_TIMED_OUT : CV_OK;\n    } finally {\n      // Re-acquire mutex\n      await mutex.lock();\n    }\n  }\n\n  /**\n   * Blocks the current agent until this condition variable is notified,\n   * or until a specified point in time is reached. The associated mutex\n   * is released before blocking and re-acquired after waking up.\n   *\n   * @param mutex The mutex that must be locked by the current agent.\n   * @param timestamp The absolute time in milliseconds at which the wait is aborted.\n   *\n   * @throws A {@link OwnershipError} If the mutex is not owned by the caller.\n   * @throws A {@link RangeError} If the shared memory data is unexpected.\n   *\n   * @returns A {@link CVStatus} representing the result of the operation.\n   */\n  async waitUntil(mutex: BasicLockable, timestamp: number): Promise<CVStatus> {\n    return this.waitFor(mutex, timestamp - performance.now());\n  }\n}\n","import type { TimedLockable } from \"../types/timedLockable\";\nimport { ATOMICS_TIMED_OUT } from \"../types/atomicsStatus\";\nimport type { SyncTimedLockable } from \"../types/sync/syncTimedLockable\";\n\nimport { LOCK_BIT, Mutex } from \"./mutex\";\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive access to shared resources / blocks of code.\n *\n * A mutex is owned from the time an agent successfully locks it\n * and until the agent unlocks it. During ownership, any other agents\n * attempting to lock the mutex will block (or receive `false` from\n * `tryLock` methods). When unlocked, any blocked agent will have\n * the chance to acquire owernship.\n *\n * A locked mutex should not be relocked by the owner. Attempts\n * for additional locks will throw an error, and calls to `tryLock`\n * methods will return `false`.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * Timeout precision for time-based methods may vary due to system load\n * and inherent limitations of JavaScript timing. Developers should\n * consider this possible variability in their applications.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/unique_lock | C++ std::unique_lock}\n */\nexport class TimedMutex\n  extends Mutex\n  implements TimedLockable, SyncTimedLockable\n{\n  async tryLockFor(timeout: number): Promise<boolean> {\n    return this.tryLockUntil(performance.now() + timeout);\n  }\n\n  tryLockForSync(timeout: number): boolean {\n    return this.tryLockUntilSync(performance.now() + timeout);\n  }\n\n  async tryLockUntil(timestamp: number): Promise<boolean> {\n    // If already has lock\n    if (this._isOwner) {\n      return false;\n    }\n    // Try to acquire lock for a given amount of time\n    while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n      const timeout = timestamp - performance.now();\n      const res = Atomics.waitAsync(this._mem, 0, LOCK_BIT, timeout);\n      const value = res.async ? await res.value : res.value;\n      // If time expired\n      if (value === ATOMICS_TIMED_OUT) {\n        return false;\n      }\n    }\n    return (this._isOwner = true);\n  }\n\n  tryLockUntilSync(timestamp: number): boolean {\n    // If already has lock\n    if (this._isOwner) {\n      return false;\n    }\n    // Try to acquire lock for a given amount of time\n    while (Atomics.or(this._mem, 0, LOCK_BIT)) {\n      const timeout = timestamp - performance.now();\n      const value = Atomics.wait(this._mem, 0, LOCK_BIT, timeout);\n      // If time expired\n      if (value === ATOMICS_TIMED_OUT) {\n        return false;\n      }\n    }\n    return (this._isOwner = true);\n  }\n}\n","import type { Lockable } from \"../types/lockable\";\nimport type { SharedResource } from \"../types/sharedResource\";\nimport type { SharedLockable } from \"../types/sharedLockable\";\n\nimport { OwnershipError } from \"../errors/ownershipError\";\nimport { RelockError } from \"../errors/relockError\";\nimport { lockGuard } from \"../locks/lockGuard\";\n\nimport { ConditionVariable } from \"../condVars/conditionVariable\";\nimport { TimedMutex } from \"./timedMutex\";\n\nexport const WRITE_BIT = 1 << 31;\nexport const READ_BITS = ~WRITE_BIT;\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive and shared access to resources / blocks of code.\n *\n * If one agent has acquired an exclusive lock, no other agents can acquire\n * the mutex. If one agent has acquired a shared lock, other agents can still\n * acquire the shared lock, but cannot acquire an exclusive lock. Within one\n * agent, only one lock (shared or exclusive) can be acquired at the same time.\n *\n * Shared mutexes are useful when shared data can be safely read by any number\n * of agents simultaneously, but should be written to by only one agent at a\n * time, and not readable by other agents during writing.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/shared_mutex | C++ std::shared_mutex}\n * 1. {@link https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html | Alexander Terekhov, Howard Hinnant. (2007-09-09). Mutex, Lock, Condition Variable Rationale}\n */\nexport class SharedMutex implements Lockable, SharedLockable, SharedResource {\n  /**\n   * The size in bytes of the mutex.\n   */\n  static readonly ByteLength = 4 * Int32Array.BYTES_PER_ELEMENT;\n\n  protected _gate1: ConditionVariable;\n  protected _gate2: ConditionVariable;\n  protected _isReader: boolean;\n  protected _isWriter: boolean;\n  protected _mem: Int32Array;\n  protected _mutex: TimedMutex;\n\n  constructor();\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the mutex.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer?: SharedArrayBuffer, byteOffset = 0) {\n    const bInt32 = Int32Array.BYTES_PER_ELEMENT;\n\n    // Sanitize input\n    sharedBuffer ??= new SharedArrayBuffer(SharedMutex.ByteLength);\n\n    // Initialize properties\n    this._mem = new Int32Array(sharedBuffer, byteOffset, 4);\n    byteOffset += bInt32;\n    this._mutex = new TimedMutex(sharedBuffer, byteOffset);\n    byteOffset += bInt32;\n    this._gate1 = new ConditionVariable(sharedBuffer, byteOffset);\n    byteOffset += bInt32;\n    this._gate2 = new ConditionVariable(sharedBuffer, byteOffset);\n    this._isReader = false;\n    this._isWriter = false;\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  get ownsLock(): boolean {\n    return this._isWriter;\n  }\n\n  get ownsSharedLock(): boolean {\n    return this._isReader;\n  }\n\n  // Exclusive\n\n  /**\n   * @throws A {@link RelockError} If the mutex is already locked by the caller.\n   */\n  async lock(): Promise<void> {\n    // If already has lock\n    if (this._isWriter || this._isReader) {\n      throw new RelockError();\n    }\n\n    // Acquire internal lock\n    await lockGuard(this._mutex, async () => {\n      // Acquire write lock\n      while (Atomics.or(this._mem, 0, WRITE_BIT) & WRITE_BIT) {\n        await this._gate1.wait(this._mutex);\n      }\n      this._isWriter = true;\n\n      // Wait until no readers\n      while (Atomics.load(this._mem, 0) & READ_BITS) {\n        await this._gate2.wait(this._mutex);\n      }\n    });\n  }\n\n  tryLock(): boolean {\n    // If already has lock\n    if (this._isWriter || this._isReader) {\n      return false;\n    }\n\n    // Try to acquire internal lock\n    if (this._mutex.tryLock()) {\n      try {\n        // Try to acquire write lock\n        this._isWriter =\n          Atomics.compareExchange(this._mem, 0, 0, WRITE_BIT) === 0;\n      } finally {\n        // Release internal lock\n        this._mutex.unlock();\n      }\n    }\n\n    // Return result\n    return this._isWriter;\n  }\n\n  /**\n   * @throws A {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  async unlock(): Promise<void> {\n    // Check if write lock owned\n    if (!this._isWriter) {\n      throw new OwnershipError();\n    }\n\n    // Acquire internal lock\n    await lockGuard(this._mutex, () => {\n      // Release write lock\n      Atomics.and(this._mem, 0, READ_BITS);\n      this._isWriter = false;\n    });\n\n    // Notify agents waiting on mutex\n    this._gate1.notifyAll();\n  }\n\n  // Shared\n\n  /**\n   * @throws A {@link RelockError} If the lock is already locked by the caller.\n   */\n  async lockShared(): Promise<void> {\n    // If already has lock\n    if (this._isReader || this._isWriter) {\n      throw new RelockError();\n    }\n\n    // Acquire internal lock\n    await lockGuard(this._mutex, async () => {\n      // Wait until there's no writer and there's read capacity\n      let state = Atomics.load(this._mem, 0);\n      while (state & WRITE_BIT || (state & READ_BITS) === READ_BITS) {\n        await this._gate1.wait(this._mutex);\n        state = Atomics.load(this._mem, 0);\n      }\n\n      // Acquire a read lock\n      Atomics.add(this._mem, 0, 1);\n      this._isReader = true;\n    });\n  }\n\n  tryLockShared(): boolean {\n    // If already has lock\n    if (this._isReader || this._isWriter) {\n      return false;\n    }\n\n    // Try to acquire internal lock\n    if (this._mutex.tryLock()) {\n      try {\n        // Check for writers and read capacity\n        const state = Atomics.load(this._mem, 0);\n        if (state & WRITE_BIT || (state & READ_BITS) === READ_BITS) {\n          return false;\n        }\n\n        // Try to acquire read lock\n        this._isReader =\n          Atomics.compareExchange(this._mem, 0, state, state + 1) === state;\n      } finally {\n        // Release internal lock\n        this._mutex.unlock();\n      }\n    }\n\n    // Return result\n    return this._isReader;\n  }\n\n  /**\n   * @throws An {@link OwnershipError} If the mutex is not owned by the caller.\n   */\n  async unlockShared(): Promise<void> {\n    // Check if read lock owned\n    if (!this._isReader) {\n      throw new OwnershipError();\n    }\n\n    // Acquire internal lock\n    await lockGuard(this._mutex, () => {\n      // Release read lock\n      const state = Atomics.sub(this._mem, 0, 1);\n      this._isReader = false;\n\n      // If there are blocked writers\n      if (state & WRITE_BIT) {\n        // And no more readers\n        if ((state & READ_BITS) === 1) {\n          // Notify blocked writers\n          this._gate2.notifyAll();\n        }\n      } else if (state === READ_BITS) {\n        // If there are no writers\n        // and readers no longer at capacity,\n        // then notify blocked readers\n        this._gate1.notifyAll();\n      }\n    });\n  }\n}\n","import { CV_TIMED_OUT } from \"../types/cvStatus\";\nimport { SharedTimedLockable } from \"../types/sharedTimedLockable\";\nimport { TimedLockable } from \"../types/timedLockable\";\n\nimport { READ_BITS, SharedMutex, WRITE_BIT } from \"./sharedMutex\";\n\n/**\n * Provides synchronization across agents (main thread and workers)\n * to allow exclusive and shared access to resources / blocks of code.\n *\n * If one agent has acquired an exclusive lock, no other agents can acquire\n * the mutex. If one agent has acquired a shared lock, other agents can still\n * acquire the shared lock, but cannot acquire an exclusive lock. Within one\n * agent, only one lock (shared or exclusive) can be acquired at the same time.\n *\n * Shared mutexes are useful when shared data can be safely read by any number\n * of agents simultaneously, but should be written to by only one agent at a\n * time, and not readable by other agents during writing.\n *\n * Behavior is undefined if:\n *    - The mutex is destroyed while being owned.\n *    - The agent is terminated while owning the mutex.\n *    - The mutex's shared memory location is modified externally.\n *\n * Timeout precision for time-based methods may vary due to system load\n * and inherent limitations of JavaScript timing. Developers should\n * consider this possible variability in their applications.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/shared_timed_mutex | C++ std::shared_timed)mutex}\n * 1. {@link https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html | Alexander Terekhov, Howard Hinnant. (2007-09-09). Mutex, Lock, Condition Variable Rationale}\n */\nexport class SharedTimedMutex\n  extends SharedMutex\n  implements TimedLockable, SharedTimedLockable\n{\n  async tryLockFor(timeout: number): Promise<boolean> {\n    return this.tryLockUntil(performance.now() + timeout);\n  }\n\n  async tryLockUntil(timestamp: number): Promise<boolean> {\n    // If already has lock\n    if (this._isWriter || this._isReader) {\n      return false;\n    }\n\n    // Try to acquire internal lock\n    if (!(await this._mutex.tryLockUntil(timestamp))) {\n      return false;\n    }\n\n    let notify = false;\n\n    try {\n      // Try to acquire write lock\n      while (Atomics.or(this._mem, 0, WRITE_BIT) & WRITE_BIT) {\n        const res = await this._gate1.waitUntil(this._mutex, timestamp);\n\n        // If timed out, stop\n        if (res === CV_TIMED_OUT) {\n          return false;\n        }\n      }\n      this._isWriter = true;\n\n      // Wait until no readers\n      while (Atomics.load(this._mem, 0) & READ_BITS) {\n        const res = await this._gate2.waitUntil(this._mutex, timestamp);\n\n        // If timed out, release write lock\n        if (res === CV_TIMED_OUT) {\n          notify = true;\n          Atomics.and(this._mem, 0, READ_BITS);\n          this._isWriter = false;\n          return false;\n        }\n      }\n\n      // Return success\n      return true;\n    } finally {\n      // Release internal lock\n      await this._mutex.unlock();\n\n      // Notify agents waiting on mutex\n      if (notify) {\n        this._gate1.notifyAll();\n      }\n    }\n  }\n\n  async tryLockSharedFor(timeout: number): Promise<boolean> {\n    return this.tryLockSharedUntil(performance.now() + timeout);\n  }\n\n  async tryLockSharedUntil(timestamp: number): Promise<boolean> {\n    // If already has lock\n    if (this._isReader || this._isWriter) {\n      return false;\n    }\n\n    // Try to acquire internal lock\n    if (!(await this._mutex.tryLockUntil(timestamp))) {\n      return false;\n    }\n\n    try {\n      // Wait until there's no writer and there's read capacity\n      let state = Atomics.load(this._mem, 0);\n      while (state & WRITE_BIT || state === READ_BITS) {\n        const res = await this._gate1.waitUntil(this._mutex, timestamp);\n\n        // If timed out, stop\n        if (res === CV_TIMED_OUT) {\n          return false;\n        }\n\n        state = Atomics.load(this._mem, 0);\n      }\n\n      // Acquire a read lock\n      Atomics.add(this._mem, 0, 1);\n      this._isReader = true;\n\n      // Return success\n      return true;\n    } finally {\n      // Release internal lock\n      await this._mutex.unlock();\n    }\n  }\n}\n","import { MultiLockError } from \"../errors/multiLockError\";\nimport { BasicLockable } from \"../types/basicLockable\";\n\n/**\n * Sequentially locks the provided {@link BasicLockable} objects.\n *\n * If any lock acquisition fails, the process is halted\n * and previously acquired locks are released in reverse order.\n *\n * @param locks - An array of lockable objects to be locked sequentially.\n *\n * @throws A {@link MultiLockError} if an error occurs trying to acquire all\n * locks. Details include:\n *  - `locks`: The array of all locks.\n *  - `numLocked`: The number of locks successfully acquired before failure.\n *  - `lockErrors`: Errors encountered while trying to acquire all locks.\n *  - `unlockErrors`: Errors encountered while trying to roll back acquired locks.\n */\nexport async function lock(...locks: BasicLockable[]): Promise<void> {\n  const N = locks.length;\n  const lockErrors: [number, unknown][] = [];\n\n  // Lock each lock. Stop at first error\n  let numLocked = N;\n  for (let i = 0; i < N; ++i) {\n    try {\n      await locks[i].lock();\n    } catch (err) {\n      lockErrors.push([i, err]);\n      numLocked = i;\n      break;\n    }\n  }\n\n  // If successful\n  if (numLocked === N) {\n    return;\n  }\n\n  // Unlock acquired locks. Collect any errors\n  const unlockErrors: [number, unknown][] = [];\n  for (let i = numLocked - 1; i >= 0; --i) {\n    try {\n      await locks[i].unlock();\n    } catch (err) {\n      unlockErrors.push([i, err]);\n    }\n  }\n\n  throw new MultiLockError(locks, numLocked, lockErrors, unlockErrors);\n}\n","import type { Lockable } from \"../types/lockable\";\n\nimport { MultiLockError } from \"../errors/multiLockError\";\nimport { MultiUnlockError } from \"../errors/multiUnlockError\";\n\n/**\n * Tries to sequentially lock the provided {@link Lockable} objects.\n *\n * If any lock acquisition fails, the process is halted\n * and previously acquired locks are released in reverse order.\n *\n * @param locks - An array of lockable objects to be locked sequentially.\n *\n * @throws A {@link MultiLockError} if an error occurs trying to acquire all\n * locks. Details include:\n *  - `locks`: The array of all locks.\n *  - `numLocked`: The number of locks successfully acquired before failure.\n *  - `lockErrors`: Errors encountered while trying to acquire all locks.\n *  - `unlockErrors`: Errors encountered while trying to roll back acquired locks.\n *\n * @throws A {@link MultiUnlockError} if, after lock failure, an errors occurs\n * while trying to roll back acquired locks. Details include:\n *  - `locks`: The array of all locks.\n *  - `numUnlocked`: The number of locks successfully unlocked.\n *  - `unlockErrors`: Errors encountered while trying to roll back acquired locks.\n *\n * @returns `-1` if all locks are successfully acquired, otherwise the 0-based index of the lock that failed.\n */\nexport async function tryLock(...locks: Lockable[]): Promise<number> {\n  const N = locks.length;\n  const lockErrors: [number, unknown][] = [];\n\n  // Lock each lock. Stop at first failure\n  let numLocked = N;\n  for (let i = 0; i < N; ++i) {\n    try {\n      if (!(await locks[i].tryLock())) {\n        numLocked = i;\n        break;\n      }\n    } catch (err) {\n      lockErrors.push([i, err]);\n      numLocked = i;\n      break;\n    }\n  }\n\n  // If successful\n  if (numLocked === N) {\n    return -1;\n  }\n\n  // If immediate failure\n  if (numLocked < 1 && lockErrors.length < 1) {\n    return numLocked;\n  }\n\n  // Unlock acquired locks. Collect any errors\n  const unlockErrors: [number, unknown][] = [];\n  for (let i = numLocked - 1; i >= 0; --i) {\n    try {\n      await locks[i].unlock();\n    } catch (err) {\n      unlockErrors.push([i, err]);\n    }\n  }\n\n  // If errors occurred\n  if (lockErrors.length > 0) {\n    throw new MultiLockError(locks, numLocked, lockErrors, unlockErrors);\n  }\n  if (unlockErrors.length > 0) {\n    const numUnlocked = numLocked - unlockErrors.length;\n    throw new MultiUnlockError(locks, numUnlocked, unlockErrors);\n  }\n\n  // Return 0-based index of failed lock\n  return numLocked;\n}\n","import type { BasicLockable } from \"../types/basicLockable\";\nimport type { Lockable } from \"../types/lockable\";\n\nimport { MultiUnlockError } from \"../errors/multiUnlockError\";\nimport { lock } from \"./lock\";\nimport { tryLock } from \"./tryLock\";\n\n/**\n * A mutex ownership wrapper.\n *\n * Locking a MultiLock exclusively locks the associated mutexes.\n *\n * If the given mutexes implement {@link Lockable}, then MultiLock will too.\n * Otherwise, using attempted locking (`tryLock`) will result in errors.\n */\nexport class MultiLock implements Lockable {\n  /**\n   * Indicates whether the current agent owns the lock.\n   */\n  protected _isOwner: boolean;\n\n  /**\n   * The associated basic lockable.\n   */\n  mutexes: BasicLockable[];\n\n  /**\n   * @param mutexes - The basic lockables to associate.\n   */\n  constructor(...mutexes: BasicLockable[]) {\n    this._isOwner = false;\n    this.mutexes = mutexes;\n  }\n\n  get ownsLock(): boolean {\n    return this._isOwner;\n  }\n\n  async lock(): Promise<void> {\n    await lock(...this.mutexes);\n    this._isOwner = true;\n  }\n\n  /**\n   * Exchange internal state\n   */\n  swap(other: MultiLock): void {\n    // Swap ownership\n    const tIsOwner = this._isOwner;\n    this._isOwner = other._isOwner;\n    other._isOwner = tIsOwner;\n    // Swap mutexes\n    const tMutexes = this.mutexes;\n    this.mutexes = other.mutexes;\n    other.mutexes = tMutexes;\n  }\n\n  async tryLock(): Promise<boolean> {\n    const res = await tryLock(...(this.mutexes as Lockable[]));\n    return (this._isOwner = res < 0);\n  }\n\n  async unlock(): Promise<void> {\n    const locks = this.mutexes;\n    const N = locks.length;\n\n    // Unlock all locks. Collect any errors\n    const unlockErrors: [number, unknown][] = [];\n    for (let i = N - 1; i >= 0; --i) {\n      try {\n        await locks[i].unlock();\n      } catch (err) {\n        unlockErrors.push([i, err]);\n      }\n    }\n\n    // Update state\n    this._isOwner = false;\n\n    // Throw any errors\n    if (unlockErrors.length > 0) {\n      const unlocked = N - unlockErrors.length;\n      throw new MultiUnlockError(Array.from(locks), unlocked, unlockErrors);\n    }\n  }\n}\n","import type { SharedLockable } from \"../types/sharedLockable\";\nimport type { SharedTimedLockable } from \"../types/sharedTimedLockable\";\nimport type { TimedLockable } from \"../types/timedLockable\";\n\n/**\n * A shared mutex wrapper.\n *\n * Locking a SharedLock locks the associated shared mutex in shared mode.\n *\n * If the shared mutex implements {@link SharedTimedLockable}, then SharedLock\n * will also implement it. Otherwise, attempts to use timed methods\n * (`tryLockFor`, `tryLockUntil`) will result in errors.\n */\nexport class SharedLock implements TimedLockable {\n  /**\n   * The associated mutex.\n   */\n  mutex: SharedLockable | undefined;\n\n  /**\n   * @param mutex - The shared lockable to associate.\n   */\n  constructor(mutex?: SharedLockable) {\n    this.mutex = mutex;\n  }\n\n  get ownsLock(): boolean {\n    return this.mutex?.ownsSharedLock ?? false;\n  }\n\n  lock(): Promise<void> {\n    return this.mutex!.lockShared();\n  }\n\n  /**\n   * Exchanges the internal states of the shared locks.\n   */\n  swap(other: SharedLock): void {\n    const temp = this.mutex;\n    this.mutex = other.mutex;\n    other.mutex = temp;\n  }\n\n  tryLock(): boolean | Promise<boolean> {\n    return this.mutex!.tryLockShared();\n  }\n\n  tryLockFor(timeout: number): Promise<boolean> {\n    return (this.mutex as SharedTimedLockable).tryLockSharedFor(timeout);\n  }\n\n  tryLockUntil(timestamp: number): Promise<boolean> {\n    return (this.mutex as SharedTimedLockable).tryLockSharedUntil(timestamp);\n  }\n\n  unlock(): void | Promise<void> {\n    return this.mutex!.unlockShared();\n  }\n}\n","import type { BasicLockable } from \"../types/basicLockable\";\nimport type { Lockable } from \"../types/lockable\";\nimport type { SyncBasicLockable } from \"../types/sync/syncBasicLockable\";\nimport type { SyncLockable } from \"../types/sync/syncLockable\";\nimport { SyncTimedLockable } from \"../types/sync/syncTimedLockable\";\nimport type { TimedLockable } from \"../types/timedLockable\";\n\n/**\n * A mutex ownership wrapper.\n *\n * Locking a UniqueLock exclusively locks the associated mutex.\n *\n * If the given mutex implements {@link Lockable}, then UniqueLock will too.\n * If the given mutex implements {@link TimedLockable}, then UniqueLock will too.\n * Otherwise, using attempted locking (e.g. `tryLock`) or timed methods\n * (e.g. `tryLockFor`, `tryLockUntil`) will result in errors.\n */\nexport class UniqueLock implements TimedLockable, SyncTimedLockable {\n  /**\n   * The associated basic lockable.\n   */\n  mutex: BasicLockable | SyncBasicLockable | undefined;\n\n  /**\n   * @param mutex - The basic lockable to associate.\n   */\n  constructor(mutex?: BasicLockable | SyncBasicLockable) {\n    this.mutex = mutex;\n  }\n\n  get ownsLock(): boolean {\n    return this.mutex?.ownsLock ?? false;\n  }\n\n  lock(): Promise<void> {\n    return (this.mutex as Lockable).lock();\n  }\n\n  lockSync(): void {\n    return (this.mutex as SyncLockable).lockSync();\n  }\n\n  /**\n   * Exchanges the internal states of the unique locks.\n   */\n  swap(other: UniqueLock): void {\n    const temp = this.mutex;\n    this.mutex = other.mutex;\n    other.mutex = temp;\n  }\n\n  tryLock(): boolean | Promise<boolean> {\n    return (this.mutex as Lockable).tryLock();\n  }\n\n  tryLockSync(): boolean {\n    return (this.mutex as SyncLockable).tryLockSync();\n  }\n\n  tryLockFor(timeout: number): Promise<boolean> {\n    return (this.mutex as TimedLockable).tryLockFor(timeout);\n  }\n\n  tryLockForSync(timeout: number): boolean {\n    return (this.mutex as SyncTimedLockable).tryLockForSync(timeout);\n  }\n\n  tryLockUntil(timestamp: number): Promise<boolean> {\n    return (this.mutex as TimedLockable).tryLockUntil(timestamp);\n  }\n\n  tryLockUntilSync(timestamp: number): boolean {\n    return (this.mutex as SyncTimedLockable).tryLockUntilSync(timestamp);\n  }\n\n  unlock(): void | Promise<void> {\n    return (this.mutex as Lockable).unlock();\n  }\n\n  unlockSync(): void {\n    return (this.mutex as SyncLockable).unlockSync();\n  }\n}\n","import { OnceFlag } from \"./onceFlag\";\n\n/**\n * Executes a callback function at most once, based on the state of a provided {@link OnceFlag}.\n *\n * This function ensures the callback is executed exactly once, even across multiple\n * calls in different agents (main thread, web workers). This is useful for one-time\n * processes, such as initialization and cleanup routines.\n *\n * - If the flag is already set, the callback is not executed and `undefined` is returned.\n *\n * - If the flag is not set, the flag is set, the callback is executed, and the callback's\n * result is returned.\n *\n * @param flag - The {@link OnceFlag} used to determine whether the callback has been invoked.\n * @param callbackfn - A function that will be called if the flag has not been set.\n *\n * @returns The result of `callbackfn` if the flag was not previously set, otherwise `undefined`.\n */\nexport function callOnce<T>(\n  flag: OnceFlag,\n  callbackfn: () => T,\n): T | undefined {\n  return flag.set() ? callbackfn() : undefined;\n}\n","import type { SharedResource } from \"../types/sharedResource\";\n\n/**\n * Represents a flag that can be set exactly once across different execution agents.\n */\nexport class OnceFlag implements SharedResource {\n  /**\n   * The size in bytes of the flag.\n   */\n  static readonly ByteLength = Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * The bit within the shared memory used to set the flag.\n   */\n  protected _bit: number;\n  /**\n   * The offset for the bit within the 32-bit integer of the shared memory.\n   */\n  protected _bitOffset: number;\n  /**\n   * The shared memory buffer used for the flag.\n   */\n  protected _mem: Int32Array;\n\n  constructor();\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the flag.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   * @param bitOffset The bit offset within the shared memory location. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   *  - `bitOffset` is negative.\n   *  - `bitOffset` is greater than or equal to `32`.\n   */\n  constructor(\n    sharedBuffer: SharedArrayBuffer,\n    byteOffset?: number,\n    bitOffset?: number,\n  );\n  constructor(sharedBuffer?: SharedArrayBuffer, byteOffset = 0, bitOffset = 0) {\n    // Sanitize input\n    sharedBuffer ??= new SharedArrayBuffer(OnceFlag.ByteLength);\n\n    // Check bit offset\n    if (bitOffset < 0) {\n      throw new RangeError(\"Invalid bit offset\", {\n        cause: `${bitOffset} < 0`,\n      });\n    }\n    if (bitOffset >= 32) {\n      throw new RangeError(\"Invalid bit offset\", {\n        cause: `${bitOffset} >= 32`,\n      });\n    }\n\n    // Initialize properties\n    this._bit = 1 << bitOffset;\n    this._bitOffset = bitOffset;\n    this._mem = new Int32Array(sharedBuffer, byteOffset, 1);\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  /**\n   * The bit offset for the flag within shared memory, relative to `byteOffset`.\n   */\n  get bitOffset(): number {\n    return this._bitOffset;\n  }\n\n  /**\n   * Resets the flag state to `false`.\n   *\n   * @returns `true` if the flag was previously set, `false` otherwise.\n   */\n  clear(): boolean {\n    return (Atomics.and(this._mem, 0, ~this._bit) & this._bit) !== 0;\n  }\n\n  /**\n   * Checks if the flag is currently set.\n   *\n   * @returns `true` if the flag is set, `false` otherwise.\n   */\n  isSet(): boolean {\n    return (Atomics.load(this._mem, 0) & this._bit) !== 0;\n  }\n\n  /**\n   * Sets the flag to `true`. This operation is atomic and thread-safe.\n   *\n   * @returns `true` if the flag was set, `false` if it was already set.\n   */\n  set(): boolean {\n    return (Atomics.or(this._mem, 0, this._bit) & this._bit) === 0;\n  }\n}\n","import { CV_TIMED_OUT } from \"../types/cvStatus\";\nimport type { SharedResource } from \"../types/sharedResource\";\nimport type { TimedLockable } from \"../types/timedLockable\";\n\nimport { ConditionVariable } from \"../condVars/conditionVariable\";\nimport {\n  ERR_NEGATIVE_VALUE,\n  ERR_OVERFLOW,\n  ERR_SEM_INPUT_NEG,\n  ERR_SEM_INPUT_OVERFLOW,\n} from \"../errors/constants\";\nimport { lockGuard } from \"../locks/lockGuard\";\nimport { TimedMutex } from \"../mutexes/timedMutex\";\nimport { MAX_INT32_VALUE } from \"../utils/constants\";\n\n/**\n * A counting semaphore based on shared memory and atomics, allowing for\n * cross-agent synchronization.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/counting_semaphore | C++ std::counting_semaphore}\n */\nexport class CountingSemaphore implements SharedResource {\n  /**\n   * The size in bytes of the semaphore.\n   */\n  static readonly ByteLength = 3 * Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * The maximum possible value of the internal counter\n   */\n  static readonly Max = MAX_INT32_VALUE;\n\n  private _gate: ConditionVariable;\n  private _mem: Int32Array;\n  private _mutex: TimedLockable;\n\n  /**\n   * @param desired The initial value of the internal counter. Must be non-negative and\n   * not exceed {@link CountingSemaphore.Max}.\n   *\n   * @throws A {@link RangeError} if `desired` is negative or exceeds {@link CountingSemaphore.Max}.\n   */\n  constructor(desired: number);\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the semaphore.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer: number | SharedArrayBuffer, byteOffset = 0) {\n    const bInt32 = Int32Array.BYTES_PER_ELEMENT;\n\n    if (sharedBuffer instanceof SharedArrayBuffer) {\n      this._mem = new Int32Array(sharedBuffer, byteOffset, 3);\n      byteOffset += bInt32;\n      this._mutex = new TimedMutex(sharedBuffer, byteOffset);\n      byteOffset += bInt32;\n      this._gate = new ConditionVariable(sharedBuffer, byteOffset);\n      return;\n    }\n\n    // Check for underflow\n    const desired = sharedBuffer;\n    if (desired < 0) {\n      throw new RangeError(ERR_NEGATIVE_VALUE, {\n        cause: `${desired} < 0`,\n      });\n    }\n\n    // Check for overflow\n    if (desired > CountingSemaphore.Max) {\n      throw new RangeError(ERR_OVERFLOW, {\n        cause: `${desired} > ${CountingSemaphore.Max}`,\n      });\n    }\n\n    sharedBuffer = new SharedArrayBuffer(CountingSemaphore.ByteLength);\n    this._mem = new Int32Array(sharedBuffer, 0, 3);\n    byteOffset += bInt32;\n    this._mutex = new TimedMutex(sharedBuffer, byteOffset);\n    byteOffset += bInt32;\n    this._gate = new ConditionVariable(sharedBuffer, byteOffset);\n    this._mem[0] = desired;\n  }\n\n  get buffer(): SharedArrayBuffer {\n    return this._mem.buffer as SharedArrayBuffer;\n  }\n\n  get byteLength(): number {\n    return this._mem.byteLength;\n  }\n\n  get byteOffset(): number {\n    return this._mem.byteOffset;\n  }\n\n  /**\n   * Acquires the semaphore, blocking until it is available.\n   *\n   * @returns A promise that resolves when acquisition is successful.\n   */\n  acquire(): Promise<void> {\n    // Acquire the internal mutex within scope\n    return lockGuard(this._mutex, async () => {\n      // Wait until internal counter has capacity\n      while (Atomics.load(this._mem, 0) <= 0) {\n        await this._gate.wait(this._mutex);\n      }\n      // Decrement internal counter\n      Atomics.sub(this._mem, 0, 1);\n    });\n  }\n\n  /**\n   * Attempts to acquire the semaphore.\n   *\n   * @returns A promise resolving to `true` if successful, otherwise `false`.\n   */\n  tryAcquire(): Promise<boolean> {\n    // Acquire the internal mutex\n    return lockGuard(this._mutex, () => {\n      // Check internal counter\n      if (Atomics.load(this._mem, 0) <= 0) {\n        return false;\n      }\n      // Decrement internal counter\n      Atomics.sub(this._mem, 0, 1);\n      // Return success\n      return true;\n    });\n  }\n\n  /**\n   * Attempts to acquire the semaphore, blocking until either\n   * success or the specified timeout elapses.\n   *\n   * @param timeout The maximum duration in milliseconds to wait.\n   *\n   * @returns A promise resolving to `true` if successful, otherwise `false`.\n   */\n  tryAcquireFor(timeout: number): Promise<boolean> {\n    return this.tryAcquireUntil(performance.now() + timeout);\n  }\n\n  /**\n   * Attempts to acquire the lock, blocking until either\n   * the lock is acquired or the specified point in time is reached.\n   *\n   * @param timestamp The absolute time in milliseconds to wait until.\n   *\n   * @returns A promise resolved to `true` if succesful, otherwise `false`.\n   */\n  async tryAcquireUntil(timestamp: number): Promise<boolean> {\n    // Acquire the internal mutex\n    if (!(await this._mutex.tryLockUntil(timestamp))) {\n      return false;\n    }\n\n    try {\n      // Wait until internal counter has capacity\n      while (Atomics.load(this._mem, 0) <= 0) {\n        const status = await this._gate.waitUntil(this._mutex, timestamp);\n\n        // Stop if timed out\n        if (status === CV_TIMED_OUT) {\n          return false;\n        }\n      }\n\n      // Decrement internal counter\n      Atomics.sub(this._mem, 0, 1);\n\n      // Return success\n      return true;\n    } finally {\n      // Release internal mutex\n      await this._mutex.unlock();\n    }\n  }\n\n  /**\n   * Releases a specified number of units back to the semaphore.\n   *\n   * @param count The number of units to release. Defaults to 1.\n   *\n   * @throws {RangeError} If `count` is negative or would cause the semaphore to overflow.\n   */\n  release(count = 1): Promise<void> {\n    // Sanitize input\n    if (count < 0) {\n      throw new RangeError(ERR_SEM_INPUT_NEG, {\n        cause: `${count} < 0`,\n      });\n    }\n\n    // Acquire internal mutex\n    return lockGuard(this._mutex, () => {\n      // Get the internal counter\n      const state = Atomics.load(this._mem, 0);\n\n      // Check for overflow\n      if (count > CountingSemaphore.Max - state) {\n        throw new RangeError(ERR_SEM_INPUT_OVERFLOW, {\n          cause: `${count} > ${CountingSemaphore.Max - state}`,\n        });\n      }\n\n      // Increment the internal counter\n      Atomics.add(this._mem, 0, count);\n\n      // Notify blocked agents\n      this._gate.notifyAll();\n    });\n  }\n}\n","import type { Lockable } from \"../types/lockable\";\n\nimport { ConditionVariable } from \"../condVars/conditionVariable\";\nimport {\n  ERR_LATCH_INPUT_OVERFLOW,\n  ERR_LATCH_INPUT_UNDERFLOW,\n  ERR_OVERFLOW,\n  ERR_NEGATIVE_VALUE,\n} from \"../errors/constants\";\nimport { lockGuard } from \"../locks/lockGuard\";\nimport { Mutex } from \"../mutexes/mutex\";\nimport { MAX_INT32_VALUE } from \"../utils/constants\";\n\n/**\n * A synchronization primitive that allows one or more agents to wait until\n * a set of operations has been completed.\n *\n * @privateRemarks\n * 1. {@link https://en.cppreference.com/w/cpp/thread/latch | std::latch}\n */\nexport class Latch {\n  /**\n   * The size in bytes of the latch.\n   */\n  static readonly ByteLength = 3 * Int32Array.BYTES_PER_ELEMENT;\n\n  /**\n   * The maximum possible value of the internal counter.\n   */\n  static readonly Max = MAX_INT32_VALUE;\n\n  /**\n   * Condition variable to manage waiting agents.\n   */\n  protected _gate: ConditionVariable;\n\n  /**\n   * The shared atomic memory for the internal counter.\n   */\n  protected _mem: Int32Array;\n\n  /**\n   * Mutex to protect access to the internal counter.\n   */\n  protected _mutex: Lockable;\n\n  /**\n   * @param expected The initial value of the internal counter. Must be non-negative and\n   * not exceed {@link Latch.Max}.\n   *\n   * @throws A {@link RangeError} if `expected` is negative or exceeds {@link Latch.Max}.\n   */\n  constructor(expected: number);\n  /**\n   * @param sharedBuffer The {@link SharedArrayBuffer} that backs the latch.\n   * @param byteOffset The byte offset within `sharedBuffer`. Defaults to `0`.\n   *\n   * @throws A {@link RangeError} for any of the following:\n   *  - `byteOffset` is negative or not a multiple of `4`.\n   *  - The byte length of `sharedBuffer` is less than {@link ByteLength}.\n   *  - The space in `sharedBuffer` starting from `byteOffset` is less than {@link ByteLength}.\n   */\n  constructor(sharedBuffer: SharedArrayBuffer, byteOffset?: number);\n  constructor(sharedBuffer: number | SharedArrayBuffer, byteOffset = 0) {\n    const bInt32 = Int32Array.BYTES_PER_ELEMENT;\n\n    if (sharedBuffer instanceof SharedArrayBuffer) {\n      this._mem = new Int32Array(sharedBuffer, byteOffset, 3);\n      byteOffset += bInt32;\n      this._mutex = new Mutex(sharedBuffer, byteOffset);\n      byteOffset += bInt32;\n      this._gate = new ConditionVariable(sharedBuffer, byteOffset);\n      return;\n    }\n\n    // Check for underflow\n    const expected = sharedBuffer;\n    if (expected < 0) {\n      throw new RangeError(ERR_NEGATIVE_VALUE, {\n        cause: `${expected} < 0`,\n      });\n    }\n\n    // Check for overflow\n    if (expected > Latch.Max) {\n      throw new RangeError(ERR_OVERFLOW, {\n        cause: `${expected} > ${Latch.Max}`,\n      });\n    }\n\n    sharedBuffer = new SharedArrayBuffer(Latch.ByteLength);\n    this._mem = new Int32Array(sharedBuffer, 0, 3);\n    byteOffset += bInt32;\n    this._mutex = new Mutex(sharedBuffer, byteOffset);\n    byteOffset += bInt32;\n    this._gate = new ConditionVariable(sharedBuffer, byteOffset);\n    this._mem[0] = expected;\n  }\n\n  /**\n   * Decrements the counter by a specified amount.\n   *\n   * If the counter reaches zero, waiting agents are notified.\n   *\n   * @param n The amount to decrement the counter.\n   *\n   * @throws A {@link RangeError} If `n` is negative or exceeds the current count.\n   */\n  async countDown(n = 1): Promise<void> {\n    // Sanitize input\n    if (n < 0) {\n      throw new RangeError(ERR_LATCH_INPUT_UNDERFLOW, {\n        cause: `${n} < 0`,\n      });\n    }\n\n    // Acquire internal mutex\n    await lockGuard(this._mutex, async () => {\n      // Get the internal counter\n      const value = Atomics.load(this._mem, 0);\n\n      // Check for overflow\n      if (n > value) {\n        throw new RangeError(ERR_LATCH_INPUT_OVERFLOW, {\n          cause: `${n} > ${value}`,\n        });\n      }\n\n      // Decrement the internal counter\n      if (Atomics.sub(this._mem, 0, n) === n) {\n        // If zero reached, notify blocked agents\n        this._gate.notifyAll();\n      }\n    });\n  }\n\n  /**\n   * Decrements the counter by a specified amount, then waits for it to reach zero.\n   *\n   * If the counter is decremented to zero, waiting agents are notified.\n   *\n   * @param n The amount to decrement the counter.\n   *\n   * @throws A {@link RangeError} If `n` is negative or exceeds the current count.\n   *\n   * @returns A promise that resolves once the internal count reaches zero,\n   * allowing the agent to proceed.\n   */\n  async arriveAndWait(n = 1): Promise<void> {\n    // Sanitize input\n    if (n < 0) {\n      throw new RangeError(ERR_LATCH_INPUT_UNDERFLOW, {\n        cause: `${n} < 0`,\n      });\n    }\n\n    // Acquire internal mutex\n    await lockGuard(this._mutex, async () => {\n      // Get the internal counter\n      const value = Atomics.load(this._mem, 0);\n\n      // Check for overflow\n      if (n > value) {\n        throw new RangeError(ERR_LATCH_INPUT_OVERFLOW, {\n          cause: `${n} > ${value}`,\n        });\n      }\n\n      // Decrement the internal counter\n      if (Atomics.sub(this._mem, 0, n) === n) {\n        // If zero reached, notify blocked agents\n        this._gate.notifyAll();\n        return;\n      }\n\n      // Wait until zero reached\n      do {\n        await this._gate.wait(this._mutex);\n      } while (Atomics.load(this._mem, 0) !== 0);\n    });\n  }\n\n  /**\n   * Tests if the counter has reached zero.\n   *\n   * @returns `true` if the current count is zero, otherwise `false`.\n   */\n  tryWait(): boolean {\n    return Atomics.load(this._mem, 0) === 0;\n  }\n\n  /**\n   * Wait until the counter reaches zero.\n   *\n   * @returns A promise that resolves once the internal count reaches zero,\n   * allowing the agent to proceed.\n   */\n  async wait(): Promise<void> {\n    // Acquire internal mutex\n    await lockGuard(this._mutex, async () => {\n      // Wait until zero reached\n      while (Atomics.load(this._mem, 0) !== 0) {\n        await this._gate.wait(this._mutex);\n      }\n    });\n  }\n}\n"],"mappings":"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","names":["CV_OK","CV_TIMED_OUT","ERR_TIMEOUT","ERR_NEGATIVE_VALUE","ERR_OVERFLOW","ERR_LATCH_INPUT_UNDERFLOW","ERR_LATCH_INPUT_OVERFLOW","ERR_CV_VALUE","ERR_LOCK","ERR_LOCK_OWNERSHIP","ERR_LOCK_RELOCK","ERR_REC_MUTEX_OVERFLOW","ERR_MULTI_LOCK","ERR_MULTI_UNLOCK","ERR_SEM_INPUT_NEG","ERR_SEM_INPUT_OVERFLOW","LockError","message","ERR_LOCK","MultiLockError","LockError","locks","numLocked","lockErrors","unlockErrors","message","ERR_MULTI_LOCK","MultiUnlockError","LockError","locks","numUnlocked","unlockErrors","message","ERR_MULTI_UNLOCK","OwnershipError","LockError","message","ERR_LOCK_OWNERSHIP","RelockError","LockError","message","ERR_LOCK_RELOCK","TimeoutError","_TimeoutError","message","timeout","deadline","ERR_TIMEOUT","LOCK_BIT","Mutex","_Mutex","sharedBuffer","byteOffset","RelockError","res","OwnershipError","LOCK_BIT","RecursiveMutex","_RecursiveMutex","sharedBuffer","byteOffset","ERR_REC_MUTEX_OVERFLOW","OwnershipError","ATOMICS_NOT_EQUAL","ATOMICS_TIMED_OUT","RecursiveTimedMutex","_RecursiveTimedMutex","RecursiveMutex","timeout","timestamp","LOCK_BIT","res","ATOMICS_TIMED_OUT","lockGuard","mutex","callbackfn","lockGuardSync","ConditionVariable","_ConditionVariable","sharedBuffer","byteOffset","count","mutex","timeout","OwnershipError","res","value","ATOMICS_NOT_EQUAL","ERR_CV_VALUE","ATOMICS_TIMED_OUT","CV_TIMED_OUT","CV_OK","timestamp","TimedMutex","Mutex","timeout","timestamp","LOCK_BIT","res","ATOMICS_TIMED_OUT","WRITE_BIT","READ_BITS","SharedMutex","_SharedMutex","sharedBuffer","byteOffset","bInt32","TimedMutex","ConditionVariable","RelockError","lockGuard","OwnershipError","state","SharedTimedMutex","SharedMutex","timeout","timestamp","notify","WRITE_BIT","CV_TIMED_OUT","READ_BITS","state","lock","locks","N","lockErrors","numLocked","i","err","unlockErrors","MultiLockError","tryLock","locks","N","lockErrors","numLocked","i","err","unlockErrors","MultiLockError","numUnlocked","MultiUnlockError","MultiLock","mutexes","lock","other","tIsOwner","tMutexes","res","tryLock","locks","N","unlockErrors","err","unlocked","MultiUnlockError","SharedLock","mutex","other","temp","timeout","timestamp","UniqueLock","mutex","other","temp","timeout","timestamp","callOnce","flag","callbackfn","OnceFlag","_OnceFlag","sharedBuffer","byteOffset","bitOffset","CountingSemaphore","_CountingSemaphore","sharedBuffer","byteOffset","bInt32","TimedMutex","ConditionVariable","desired","ERR_NEGATIVE_VALUE","ERR_OVERFLOW","lockGuard","timeout","timestamp","CV_TIMED_OUT","count","ERR_SEM_INPUT_NEG","state","ERR_SEM_INPUT_OVERFLOW","Latch","_Latch","sharedBuffer","byteOffset","bInt32","Mutex","ConditionVariable","expected","ERR_NEGATIVE_VALUE","ERR_OVERFLOW","n","ERR_LATCH_INPUT_UNDERFLOW","lockGuard","value","ERR_LATCH_INPUT_OVERFLOW"]}